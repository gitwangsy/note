# 复习

- [复习](#复习)
  - [1. C 基础](#1-c-基础)
    - [1.1 Ubuntu 的操作](#11-ubuntu-的操作)
      - [1.1.1 终端快捷键](#111-终端快捷键)
      - [1.1.2 命令行提示符说明](#112-命令行提示符说明)
      - [1.1.3 Linux 文件系统](#113-linux-文件系统)
      - [1.1.4 Linux 常用命令](#114-linux-常用命令)
      - [1.1.5 vi/vim 编辑器](#115-vivim-编辑器)
    - [1.2 C 入门](#12-c-入门)
      - [1.2.1 C 程序的结构](#121-c-程序的结构)
      - [1.2.2 gcc 编译器](#122-gcc-编译器)
      - [1.2.3 计算机中数据的存储](#123-计算机中数据的存储)
      - [1.2.4 数据类型](#124-数据类型)
      - [1.2.5 常量](#125-常量)
      - [1.2.6 变量](#126-变量)
      - [1.2.7 类型转换](#127-类型转换)
      - [1.2.8 运算符](#128-运算符)
      - [1.2.9 程序流程控制](#129-程序流程控制)
      - [1.2.10 数组](#1210-数组)
      - [1.2.11 字符数组和字符串](#1211-字符数组和字符串)
      - [1.2.12 指针](#1212-指针)
      - [1.2.13 指针和数组](#1213-指针和数组)
      - [1.2.14 指针和函数](#1214-指针和函数)
      - [1.2.15 全局和局部](#1215-全局和局部)
  - [2. C 高级](#2-c-高级)
    - [2.1 Makefile](#21-makefile)
  - [3. 数据结构](#3-数据结构)
    - [3.1 什么是数据结构](#31-什么是数据结构)
    - [3.2 什么是算法](#32-什么是算法)
    - [3.3 顺序表](#33-顺序表)
    - [3.4 链表](#34-链表)
      - [3.4.1 单链表](#341-单链表)
      - [3.4.2 单向循环链表](#342-单向循环链表)
      - [3.4.3 双链表](#343-双链表)
      - [3.4.4 双向循环链表](#344-双向循环链表)
    - [3.5 栈](#35-栈)
    - [3.6 队列](#36-队列)
    - [3.7 树](#37-树)
    - [3.8 总结](#38-总结)
      - [3.8.1 顺序表](#381-顺序表)
      - [3.8.2 单链表](#382-单链表)
      - [3.8.3 单向循环链表](#383-单向循环链表)
      - [3.8.4 双链表](#384-双链表)
      - [3.8.5 双向循环链表](#385-双向循环链表)
      - [3.8.6 栈](#386-栈)
      - [3.8.7 队列](#387-队列)
      - [3.8.8 树](#388-树)
    - [3.9 算法](#39-算法)
      - [3.9.1 快速排序](#391-快速排序)
      - [3.9.2 冒泡排序](#392-冒泡排序)
      - [3.9.3 Hash 查找](#393-hash-查找)
  - [4. IO 进程线程](#4-io-进程线程)
    - [4.1 系统调用与库函数](#41-系统调用与库函数)
    - [4.2 标准 IO](#42-标准-io)
    - [4.3 标准 IO 缓冲区](#43-标准-io-缓冲区)
    - [4.4 文件 IO](#44-文件-io)
    - [4.5 文件属性](#45-文件属性)
    - [4.6 目录操作](#46-目录操作)
    - [4.7 库的制作及使用](#47-库的制作及使用)
    - [4.8 进程](#48-进程)
      - [4.8.1 进程的概念](#481-进程的概念)
      - [4.8.2 进程的组成](#482-进程的组成)
      - [4.8.3 进程的种类](#483-进程的种类)
      - [4.8.4 PID](#484-pid)
      - [4.8.5 进程相关 shell 命令](#485-进程相关-shell-命令)
      - [4.8.6 进程的状态](#486-进程的状态)
      - [4.8.7 进程状态切换](#487-进程状态切换)
      - [4.8.8 进程的优先级](#488-进程的优先级)
      - [4.8.9 进程 API](#489-进程-api)
      - [4.8.10 守护进程创建流程](#4810-守护进程创建流程)
      - [4.8.11 进程内程序的替换](#4811-进程内程序的替换)
    - [4.9 进程间通信(7 种)](#49-进程间通信7-种)
      - [4.9.1 传统进程间通信方式](#491-传统进程间通信方式)
        - [4.9.1.1 无名管道](#4911-无名管道)
        - [4.9.1.2 有名管道](#4912-有名管道)
        - [4.9.1.3 信号](#4913-信号)
      - [4.9.2 system V 进程间通信方式](#492-system-v-进程间通信方式)
        - [4.9.2.1 消息队列](#4921-消息队列)
        - [4.9.2.2 共享内存](#4922-共享内存)
        - [4.9.2.3 信号量(信号灯集)](#4923-信号量信号灯集)
      - [4.9.3 BSD 进程间通信方式](#493-bsd-进程间通信方式)
    - [4.10 线程](#410-线程)
      - [4.10.1 线程的概念](#4101-线程的概念)
      - [4.10.2 线程 API](#4102-线程-api)
    - [4.11 多线程同步互斥](#411-多线程同步互斥)
      - [4.11.1 互斥](#4111-互斥)
      - [4.11.2 同步](#4112-同步)
        - [4.11.2.1 无名信号量](#41121-无名信号量)
        - [4.11.2.2 条件变量](#41122-条件变量)
    - [4.12 线程池](#412-线程池)
  - [5. 网络编程](#5-网络编程)
    - [5.1 网络编程基础](#51-网络编程基础)
    - [5.2 网络发展的历史](#52-网络发展的历史)
    - [5.3 TCP/UDP](#53-tcpudp)
    - [5.4 网络相关的基础知识](#54-网络相关的基础知识)
      - [5.4.1 字节序](#541-字节序)
      - [5.4.2 socket](#542-socket)
      - [5.4.3 网络地址(IP 地址)](#543-网络地址ip-地址)
      - [5.4.4 端口号](#544-端口号)
    - [5.5 网络编程](#55-网络编程)
      - [5.5.1 TCP 网络编程](#551-tcp-网络编程)
      - [5.5.2 UDP 网络编程](#552-udp-网络编程)
      - [5.5.3 wireshark 抓包](#553-wireshark-抓包)
      - [5.5.4 TCP/UDP 网络编程总结](#554-tcpudp-网络编程总结)
    - [5.6 IO 模型](#56-io-模型)
    - [5.7 服务器模型](#57-服务器模型)
    - [5.8 网络超时检测](#58-网络超时检测)
  - [6. C++基础](#6-c基础)
  - [7. ARM 体系结构与接口技术](#7-arm-体系结构与接口技术)
    - [7.1 名词解释](#71-名词解释)
    - [7.2 Cortex-A7 内核工作模式](#72-cortex-a7-内核工作模式)
    - [7.3 Cortex-A7 内核寄存器](#73-cortex-a7-内核寄存器)
    - [7.4 ARM 内核存储系统](#74-arm-内核存储系统)
    - [7.5 指令流水线](#75-指令流水线)
    - [7.6 ARM 指令集](#76-arm-指令集)
    - [7.7 GPIO 简介](#77-gpio-简介)
    - [7.8 串口简介](#78-串口简介)
  - [8. ARM Linux 驱动开发](#8-arm-linux-驱动开发)

## 1. C 基础

### 1.1 Ubuntu 的操作

#### 1.1.1 终端快捷键

打开终端方式:

- `Ctrl + Alt + T` 打开一个新的终端
- `Ctrl + Shift + T` 打开一个新的终端标签页（左右分屏，同路径）
- `Ctrl + Shift + N` 打开一个新的终端窗口（同路径）

终端字体调整：

- `Ctrl + Shift + +` 字体放大
- `Ctrl + -` 字体缩小

输入中文：

- `Ctrl + 空格` 切换输入法
- `shift` 切换中英文

#### 1.1.2 命令行提示符说明

`linux@ubuntu:~$`

- `linux` 当前登录的用户名
- `@` 分隔符
- `ubuntu` 主机名
- `:` 分隔符
- `~` 当前所在的目录，`~` 表示用户的家目录，`~` 也可以用绝对路径表示，如 `/home/linux`
- `$` 命令提示符，表示当前用户为普通用户，`#` 表示当前用户为超级用户(root)
  普通用户也可以通过 `sudo` 命令临时获取超级用户权限

命令行提示符可以通过修改 `PS1` 环境变量来修改显示的内容，修改后只对当前终端有效
`export PS1="xxx"` `export` 表示导出环境变量

```bash
PS1="\u@\h:\w\$"
```

- `\u` 当前登录的用户名
- `\h` 主机名
- `\w` 当前所在的目录

命令行高亮显示：

```bash
PS1="\[\e[1;31m\]\u@\h:\w\$ \[\e[0m\]"
```

- `\[\e[1;31m\]` 开始高亮显示，`1` 表示高亮显示，`31` 表示红色
- `\[\e[0m\]` 结束高亮显示

#### 1.1.3 Linux 文件系统

`/`：根目录，所有目录的起始点，一般不存放任何文件，只存放目录。

Linux 一级目录及其作用表：

| 目录        | 作用                                     |
| ----------- | ---------------------------------------- |
| /bin        | 存放系统命令                             |
| /boot       | 存放系统启动文件                         |
| **/dev**    | 存放设备文件(device)                     |
| **/etc**    | 存放系统配置文件                         |
| /home       | 存放普通用户的主目录                     |
| /lib        | 存放系统库文件                           |
| /lost+found | 存放系统异常产生的文件                   |
| /media      | 自动识别的设备挂载点                     |
| **/mnt**    | 手动挂载的设备挂载点(mount)              |
| /opt        | 存放第三方软件                           |
| **/proc**   | 存放系统和进程信息(process)              |
| /root       | 超级用户的主目录                         |
| /sbin       | 存放与系统环境设置相关的命令             |
| /srv        | 存放服务相关的数据                       |
| /sys        | 存放系统硬件信息                         |
| /tmp        | 存放临时文件                             |
| **/usr**    | 存放系统应用程序(Unix Software Resource) |
| /var        | 存放系统日志(Variable)                   |

/etc 目录及其作用表：

| 目录              | 作用                   |
| ----------------- | ---------------------- |
| /etc/passwd       | 存放用户信息           |
| /etc/group        | 存放用户组信息         |
| /etc/shadow       | 存放用户密码信息       |
| /etc/fstab        | 存放文件系统挂载信息   |
| /etc/hosts        | 存放主机名和 IP 映射   |
| **/etc/services** | 存放端口号和服务名映射 |

/usr 目录及其作用表：

| 目录             | 作用             |
| ---------------- | ---------------- |
| **/usr/bin**     | 存放系统命令     |
| /usr/lib         | 存放系统库文件   |
| /usr/src         | 存放内核源代码   |
| /usr/sbin        | 存放系统管理命令 |
| /usr/local       | 存放第三方软件   |
| **/usr/include** | 存放头文件       |
| /usr/share       | 存放共享数据     |
| /usr/share/doc   | 存放文档说明     |

/proc 目录及其作用表：

| 目录              | 作用             |
| ----------------- | ---------------- |
| /proc/cpuinfo     | 存放 CPU 信息    |
| /proc/meminfo     | 存放内存信息     |
| **/proc/devices** | 存放设备信息     |
| /proc/filesystems | 存放文件系统信息 |
| /proc/loadavg     | 存放系统负载信息 |
| **/proc/version** | 存放内核版本信息 |

/var 目录及其作用表：

| 目录       | 作用                  |
| ---------- | --------------------- |
| /var/log   | 存放系统日志          |
| /var/spool | 存放服务相关数据      |
| /var/run   | 存放服务相关数据(PID) |
| /var/lock  | 存放锁文件            |
| /var/tmp   | 存放临时文件          |
| /var/mail  | 存放邮件              |
| /var/www   | 存放网站相关数据      |

#### 1.1.4 Linux 常用命令

命令格式：`命令 [选项] [参数]`

- 选项一般分为短选项和长选项，短选项使用 `-` 开头，长选项使用 `--` 开头
- 选项可以写在一起，如 `-a -l` 可以写成 `-al`
- 选项和参数可以换位置

`ls` 命令：

| 命令         | 作用                                         |
| ------------ | -------------------------------------------- |
| ls           | 列出目录内容                                 |
| ls -a        | 列出目录内容，包括隐藏文件(以.开头)          |
| ls -l        | 列出目录内容，详细信息                       |
| ls -lh       | 列出目录内容，详细信息，文件大小单位为 K M G |
| ls 目录名    | 列出指定目录内容                             |
| ls -l 文件名 | 列出指定文件信息                             |

文件详细信息：

`-rw-rw-r--  1 linux linux 612418 5月  31  2022 xxx.tar.gz`

从左到右：

- `-` 文件类型 (-dlbcps)

  | 字符 | 文件类型 |
  | ---- | -------- |
  | -    | 普通文件 |
  | d    | 目录     |
  | l    | 链接文件 |
  | b    | 块设备   |
  | c    | 字符设备 |
  | p    | 管道文件 |
  | s    | 套接字   |

- `rw-rw-r--` 文件权限

  | 字符 | 作用                 |
  | ---- | -------------------- |
  | r    | 可读(4)              |
  | w    | 可写(2)              |
  | x    | 可执行(exec)(1)      |
  | -    | 不可读不可写不可执行 |

- `1` 硬链接数
- `linux` 所属用户
- `linux` 所属组
- `612418` 文件大小(单位字节)
- `5月  31  2022` 时间戳，最后修改时间
- `xxx.tar.gz` 文件名

`cd` 命令：

| 命令      | 作用                   |
| --------- | ---------------------- |
| cd        | 切换到当前用户的主目录 |
| cd -      | 切换到上次所在目录     |
| cd ~      | 切换到当前用户的主目录 |
| cd ..     | 切换到上级目录         |
| cd 目录名 | 切换到指定目录         |
| cd /      | 切换到根目录           |

`touch` 命令：创建空文件
如果文件存在，则修改文件的时间戳

`mkdir` 命令：创建目录

- `-p` 递归创建目录 `mkdir -p a/b/c/d/e/f/g`
- `-m` 指定权限 `mkdir -m 777 a`

`rm` 命令：删除文件或目录

- `-r` 递归删除目录 `rm -r dir1`
- `-f` 强制删除，不提示 `rm -f file1`

`cp` 命令：复制文件或目录

- `-r` 递归复制目录 `cp -r dir1 dir2`
- `-p` 保留文件属性 `cp -p file1 file2`

`mv` 命令：移动文件或目录，也可以用来重命名

- `mv file1 file2` 重命名
- `mv file1 dir1` 移动文件

`cat` 命令：查看文件内容

- `-n` 显示行号 `cat -n file1`

`echo` 命令：输出内容(回显)

- `-e` 支持转义字符 `echo -e "hello\nworld"`
- `-n` 不换行 `echo -n "hello"`

`su` 命令：切换用户

- `su root` 切换到 root 用户
- `su - root` 切换到 root 用户，并且切换到 root 用户的主目录

其他常用命令：
| 命令 | 作用 |
| --------- | ---------------------- |
| whomai | 显示当前用户名 |
| clear | 清屏 |
| date | 显示当前时间 |
| cal | 显示当前月份的日历 |
| pwd | 显示当前所在目录 |
| exit | 退出当前用户 |
| history | 查看历史命令 |
| man | 查看命令的帮助信息 |
| which | 查看命令的绝对路径 |

#### 1.1.5 vi/vim 编辑器

vi 是 vim 的前身，vim 是 vi 的升级版

vi/vim 编辑器有三种模式：

- 命令行模式：启动 vi/vim 时进入的模式，可以执行命令
- 插入模式：在命令行模式下按下 `i` 键进入插入模式，可以输入内容
- 底行模式：在命令行模式下按下 `:` 键进入底行模式，可以执行命令

命令行模式下的常用命令：

| 命令   | 作用                                                         |
| ------ | ------------------------------------------------------------ |
| i      | 在光标前插入(insert)                                         |
| I      | 在行首插入                                                   |
| a      | 在光标后插入(append)                                         |
| A      | 在行尾插入                                                   |
| o      | 在光标所在行的下方插入一行                                   |
| O      | 在光标所在行的上方插入一行                                   |
| x      | 删除光标所在位置的字符                                       |
| dd     | 删除光标所在行(delete)                                       |
| ndd    | 删除光标所在行及其下面的 n-1 行                              |
| yy     | 复制光标所在行(copy)                                         |
| nyy    | 复制光标所在行及其下面的 n-1 行                              |
| p      | 在光标所在行的下方粘贴(paste)                                |
| P      | 在光标所在行的上方粘贴                                       |
| gg     | 跳转到文件开头(goto)                                         |
| G      | 跳转到文件末尾                                               |
| ngg    | 跳转到第 n 行                                                |
| /word  | 搜索 word ，回车后跳转到第一个匹配的位置，n 下一个，N 上一个 |
| /^word | 搜索以 word 开头的行                                         |
| /word$ | 搜索以 word 结尾的行                                         |
| u      | 撤销(undo)                                                   |
| ctrl+r | 重做 反撤销(redo)                                            |

底行模式下的常用命令：

| 命令                  | 作用                                            |
| --------------------- | ----------------------------------------------- |
| :w                    | 保存                                            |
| :q                    | 退出                                            |
| :wq                   | 保存并退出                                      |
| :q!                   | 强制退出，不保存                                |
| :x                    | 保存并退出，如果文件没有修改则不保存            |
| :set nu               | 显示行号                                        |
| :set nonu             | 取消显示行号                                    |
| :set nu！             | 切换行号显示状态                                |
| :set hlsearch!        | 切换高亮显示状态                                |
| :noh                  | 取消高亮显示                                    |
| :s/word1/word2        | 当前行 word1 替换 为 word2                      |
| :%s/word1/word2/g     | 替换 word1 为 word2，% 表示全文，g 表示全局替换 |
| :%s/word1/word2/gc    | 替换 word1 为 word2，c 表示确认替换             |
| :n1,n2s/word1/word2/g | 替换 n1 到 n2 行的 word1 为 word2               |

### 1.2 C 入门

#### 1.2.1 C 程序的结构

```c
#include <stdio.h>

int main(int argc, const char *argv[])
{
    printf("hello world\n");
    return 0;
}
```

- `#include <stdio.h>`：**预处理指令**，告诉编译器在编译之前先包含 stdio.h 头文件
- `int main()`：主函数，程序的入口，程序从这里开始执行

`#` 在 C 语言中的作用：

1. 预处理指令：告诉编译器在编译之前先执行一些操作。包括：
   - `#include`：包含头文件
   - `#define`：定义宏
   - `#if`：条件编译
   - `#endif`：结束条件编译
   - `#error`：输出错误信息
   - `#pragma`：指定编译器的一些特殊操作
2. 标记符：在宏定义中，`#` 用于**将宏参数转换为字符串**
3. 字符串化：在宏定义中，`##` 用于**将两个宏参数连接成一个字符串**

#### 1.2.2 gcc 编译器

编程语言分为编译型语言和解释型语言：

- 编译型语言：源代码 -> 编译器 -> 机器码 -> 执行
  执行效率较高，但比较依赖编译器的架构或者版本，跨平台性较差
- 解释型语言(脚本语言)：源代码 -> 解释器 -> 执行
  跨平台性较好，但是执行效率较低，解释器逐行解释执行

gcc 是 GNU 编译器套件的 C 语言编译器，可以将 C 语言源代码编译成可执行文件

编译过程：

1. 预处理：处理预处理指令，展开头文件，替换宏定义，删除注释，生成 .i 文件
   `gcc -E hello.c -o hello.i`
2. 编译：语法检查，生成汇编代码，生成 .s 文件
   `gcc -S hello.i -o hello.s`
3. 汇编：将汇编文件生成目标文件(二进制文件)，生成 .o 文件
   `gcc -c hello.s -o hello.o`
4. 链接：将目标文件和库文件链接成可执行文件，生成 .out 文件
   `gcc hello.o -o hello.out`

#### 1.2.3 计算机中数据的存储

计算机中数据的存储分为两大部分：数值型数据的存储 和 非数值型数据的存储

- 数值型数据的存储：整型、浮点型、字符型
  数值型数据的表示形式：原码、反码、补码
- 非数值型数据的存储：指针、数组、结构体、共用体、枚举
  非数值型数据的表示形式：地址

进制转换：

- 任何进制转十进制：按权展开求和
- 十进制转二进制：除 2 取余(商为 0 时停止)，逆序排列
- 一位八进制数对应三位二进制数，一位十六进制数对应四位二进制数

```c
a = 0b1010; // 二进制
a = 012; // 八进制 %#o %#O # 表示输出前导符
a = 0xa; // 十六进制 %#x %#X
```

不管几进制的数，最终在计算机中都会转换成二进制来处理。

常见的字符对应的 ascii 码：

- '0' - '9'：48 - 57
- 'A' - 'Z'：65 - 90
- 'a' - 'z'：97 - 122
- '\0'：0
- '\n'：10

#### 1.2.4 数据类型

内存分配的最小单位：字节 byte

数据类型的作用：决定了数据在内存中的分配大小和数据的存储格式

基本数据类型：整型、浮点型、字符型
构造数据类型：数组、结构体、共用体、枚举
指针类型：指针
空类型：void

- 整型：char(1)、short(2)、int(4)、long(4)(32 位)、long long(8)
  其中每种类型又分为 有符号的(signed) 和 无符号的(unsigned)
  有符号的：最高位为符号位，0 表示正数，1 表示负数
  为了解决正负零的问题，实际存储数据是存储的补码:
  (正数的补码是其本身，负数的补码是其反码加 1)
  **规定**如：10000000 是 -128 (-2^7) 的补码(负数比正数多一个)
  > char 字符类型能存储的数据的范围：
  > 无符号数： 0 ~ 2^8-1
  > 有符号数： -2^7 ~ 2^7-1
- 浮点型(实型)：float(4)、double(8)
  浮点数的存储格式：符号位 + 指数位 + 尾数位
  float：1 + 8 + 23
  double：1 + 11 + 52
  浮点型数据存储的都是近似值。
- 空类型：void(不占用内存空间)
  用于函数的返回值，表示无返回值
  用于函数的参数，表示不接受参数
  **用于指针，表示不指向任何类型的数据**

规则：**存储时看数据(正负)，取出时看类型(有无符号)。**

#### 1.2.5 常量

常量：程序运行过程中，其值不允许发生改变的量

常量的分类：

|  常量类型  | 常量的表示形式 |   举例    |  输出占位符   |
| :--------: | :------------: | :-------: | :-----------: |
|  整型常量  |    10 进制     |    123    |      %d       |
|            |     2 进制     |  0b1010   |      无       |
|            |     8 进制     |   0123    | %o/%O/%#o/%#O |
|            |    16 进制     |   0x123   |      %x       |
| 浮点型常量 |     十进制     |  123.456  |    %f/%lf     |
|            |    指数形式    | 1.23456e2 |     %e/%E     |
| 字符型常量 |     单引号     |    'a'    |      %c       |
| 字符串常量 |     双引号     |  "hello"  |      %s       |

格式化输出格式控制：

| 格式控制符 | 说明                                                     |
| :--------: | :------------------------------------------------------- |
|     %%     | 输出一个百分号                                           |
|    %.nf    | 输出实型数据时，保留小数点后 n 位                        |
|   %m.nf    | 输出实型数据时，整体占 m 位，小数点后保留 n 位           |
|    %md     | 输出整型数据时，占 m 位，如果不足 m 位，则左边用空格补齐 |
|    %0md    | 输出整型数据时，占 m 位，如果不足 m 位，则左边用 0 补齐  |
|    %-d     | 输出整型数据时，左对齐                                   |
|    %+d     | 输出整型数据时，输出正号                                 |
|     %p     | 输出指针地址                                             |

```c
// eg: 将 'M' 转换成 'm'
char ch = 'M' + ('a' - 'A');
// eg: 将 '6' 转换成 6
int num = '6' - '0';
```

每个字符串的结尾都会有一个隐藏的字符 `'\0'` 用来标识字符串结束的
C 语言中对字符串的处理是遇到 `'\0'` 就结束

一般情况下，**宏名都采用大写字母**。eg: `#define PI 3.14`
宏定义的本质是**文本替换**，在预处理阶段就已经完成了替换，不会占用内存空间。

#### 1.2.6 变量

变量：程序运行过程中，其值允许发生改变的量

定义变量的语法：`存储类型 数据类型 变量名 = 初始值;`

- 存储类型：auto(自动)、static(静态)、register(寄存器)、extern(外部)、const(常量)、volatile(易变) [见 C 高级](#2-c-高级) <!-- 这是一个锚点，用于跳转 -->
  局部变量不写存储类型，默认的 auto
- 数据类型：决定了数据在内存中的分配大小和数据的存储格式
- 变量名：是一个标识符
- 初始值：可以省略，省略时变量的值是不确定的

左值和右值：

- 左值：可以出现在赋值运算符左边的值，必须是一个变量
- 右值：可以出现在赋值运算符右边的值，可以是常量、变量、表达式

#### 1.2.7 类型转换

类型转换：将一个数据强制转换成另外一种数据类型

显式类型转换：(数据类型)变量名，强制类型转换
隐式类型转换：自动完成的类型转换，编译器根据上下文自动推导

小的数据类型转换成大的数据类型，不会丢失数据，不需要强制类型转换(隐式)
大的数据类型转换成小的数据类型，可能会丢失数据，编译器报警告，需要强制类型转换(显式)

注意：**强制类型转换不会影响变量自身的类型，变量的类型只和定义时的类型有关。**
注意：**有符号数和无符号数参与运算时，会将有符号数隐式强转成无符号数来参与运算。**

#### 1.2.8 运算符

运算符：用于对常量和变量进行操作的符号

- 算术运算符：+、-、\*、/、%、++、--
  模除运算符要求左右操作数必须是整型。
- 赋值运算符：=、+=、-=、\*=、/=、%=
- 关系运算符：>、<、>=、<=、==、!=
- 逻辑运算符：&&、||、!
  短路原则：从左到右运算，如果能够确定整个表达式的结果，就不再计算后面的表达式。
- 位运算符：&、|、^、~、<<、>>
  位运算都是针对二进制而言的，不管几进制的数据，只要是做位运算，都会**转换成二进制来参与运算**。
  一般使用位运算时，用的都是**无符号数**。
  tips: 置 0 与 0，置 1 或 1，取反异或 1。
- 条件运算符：?:
- 逗号运算符：,
  执行时，从左到右每个表达式都会执行，取最后一个表达式的结果作为整个逗号运算符表达式的结果。
- 指针运算符：&、\*
- sizeof 运算符：sizeof(数据类型/变量名)
  不是函数，使用时可不加括号，但是加上括号更符合语法习惯。
  64 位系统将程序按 32 位编译时需要加编译选项`-m32`

单目运算符：只需要一个操作数的运算符
双目运算符：需要两个操作数的运算符
三目运算符：需要三个操作数的运算符(C 语言中只有一个三目运算符 ?:)

运算符优先级和结合性一览表：

![运算符优先级和结合性一览表](https://pic.imgdb.cn/item/648705e31ddac507cc0ef287.png)

一些容易出错的优先级问题：

![一些容易出错的优先级问题](https://pic.imgdb.cn/item/6487073a1ddac507cc1186c5.png)

运算符优先级：**单算移关与，异或逻条赋。**

结合方向**从右往左**的只有三个：赋值运算符、**单目运算符**、三目运算符

#### 1.2.9 程序流程控制

C 语言程序的结构有三种：顺序结构、分支结构(选择结构)、循环结构。

注意：

- `if(x)`表达式的结果取决于 x，**x 为非 0 即为真**，x 为 0 即为假，等价于`if(x != 0)`
- switch 后面的表达式的结果必须是整型或者字符型，**不能是浮点型**
  case 后面的值必须是**常量**，不能是变量
  没有 break 语句，会出现**穿透**现象，即不再判断后面的 case，直接执行后面的 case 语句。
- for 循环三个表达式，如果有哪个不需要，都可以不写，但是`;;`必须写。
  每个表达式也可以有多句，每句之间用逗号分隔。

辅助控制语句：

- break：用在 switch 语句中，用于结束 switch 语句。用在循环语句中，用于结束本层循环。
- continue：用在循环语句中，用于结束本层本次循环，继续下一次循环。
- goto：用于无条件跳转到指定的标号处。
- return：用于结束函数，返回函数的返回值。

#### 1.2.10 数组

数组：**相同类型的数据**的集合，是一种**线性表**数据结构，即用一组**连续的内存空间**来存储一组相同类型的数据。

数组名：**数组在内存中的首地址，是一个常量**，是右值，不能被赋值。

二维数组必须指定第二维的大小，第一维可以不指定，但是必须初始化。

#### 1.2.11 字符数组和字符串

字符串：**以'\0'结尾的字符数组**，'\0'是字符串结束标志，不是字符串的一部分。

字符串的长度：**不包含'\0'的字符个数**。
字符串字符数组的长度：**包含'\0'的字符个数**。

字符串处理函数：

- strlen：获取字符串的长度，不包含'\0'。
- strcpy：字符串拷贝，将源字符串拷贝到目标字符串中，包含'\0'。(目标在前源在后)
- strcat：字符串拼接，将源字符串拼接到目标字符串后面，包含'\0'。
- strcmp：字符串比较，比较两个字符串是否相等，相等返回 0，不相等返回非 0 值。
  逐个比较两个字符串中字符的 ascii 码，直到出现大小关系就立即返回。
  **第一个'\0'之前**的所有字符串都相等，才认为两个字符串相等。

#### 1.2.12 指针

指针：**存储地址的变量**，指针变量存储的是**地址**，地址是**整数**，指针变量是**整型变量**。
内存中**每个字节**都有一个编号，这个编号就是地址。

野指针：指针变量指向的地址是不确定的，是随机的，这种指针就是野指针。
空指针：指针变量指向的地址是 0，这种指针就是空指针。(NULL->(void\*)0)

段错误：访问了不属于本程序的内存空间，或者访问了本程序没有权限访问的内存空间。

指针占用空间的大小和类型无关，只和操作系统有关，32 位操作系统占用 4 个字节，64 位操作系统占用 8 个字节。

指针的运算：

- 指针加减整数：指针加减整数，指针会根据整数的值向前或者向后移动整数个类型所占用的字节数。
- 指针减指针：两个指针相减，结果是两个指针之间相差的元素个数。
- 指针比较：两个指针进行比较，比较的是两个指针**所指向的地址的大小**。

大小端：数据在内存中存储的顺序。

- 小端存储：低位字节存储在低位地址，高位字节存储在高位地址。
- 大端存储：低位字节存储在高位地址，高位字节存储在低位地址。

```c
// eg:结合指针实现 strlen 函数的功能
int my_strlen(char *str)
{
    int len = 0;
    while (*str++)
      len++;
    return len;
}

// eg:结合指针实现 strcpy 函数的功能
char *my_strcpy(char *dest, char *src)
{
    char *ret = dest; // 保存目标字符串的首地址
    while (*dest++ = *src++)
      ;
    return ret;
}

// eg:结合指针实现 strcat 函数的功能
char *my_strcat(char *dest, char *src)
{
    char *ret = dest;
    while (*dest)
      dest++;
    while (*dest++ = *src++)
      ;
    return ret;
}

// eg:结合指针实现 strcmp 函数的功能
int my_strcmp(char *str1, char *str2)
{
    while (*str1 == *str2)
    {
        if (*str1 == '\0')
          return 0;
        str1++;
        str2++;
    }
    return *str1 - *str2;
}
```

#### 1.2.13 指针和数组

指针指向数组首地址之后有如下的等价关系：

`*(p+i)` == `p[i]`
`*(*(p+i)+j)` == `p[i][j]`

数组指针就是二维数组。
指针数组就是二级指针。

二级指针多用于将一级指针的地址作为函数的参数传递时。

const 修饰变量时，表示是一个**只读变量**，不能通过变量名修改变量的值，但是可以通过指针修改变量的值。

const 修饰指针时，要看 const 和\*的相对位置关系：

- 如果 const 在\*的左边，表示修饰的是\*p
  不能通过指针修改指向的空间里的内容，指针的指向可以修改
- 如果 const 在\*的右边，表示修饰的是 p
  允许通过指针修改指向的空间里的内容，但是指针的指向不可以修改
- 如果\*的左右都有 const 表示都不能修改

#### 1.2.14 指针和函数

[一文看懂指针](https://www.runoob.com/w3cnote/c-pointer-detail.html)

如果在函数中需要**修改实参的值**，就需要传递实参的地址，这样在函数中就可以通过指针修改实参的值。

main 函数的参数：

- argc：argument count，表示传递给 main 函数的参数个数。(./a.out 也算一个参数)
- argv：argument vector，表示传递给 main 函数的参数列表。

#### 1.2.15 全局和局部

全局变量：定义在函数外部的变量。
局部变量：定义在函数内部的变量。

全局变量和局部变量的区别：

- 作用域不同：全局变量在整个工程中都可以访问，局部变量只能在函数内部访问。
- 生命周期不同：全局变量在程序启动时创建，在程序结束时销毁，局部变量在函数调用时创建，在函数调用结束时销毁。
- 存储位置不同：全局变量存储在静态区，局部变量存储在栈区。

全局变量即使不初始化，系统也会自动初始化为 0。

```c
// eg:转换为二进制并输出
void print_bin(int num)
{
    for (int i = sizeof(num) * 8 - 1; i >= 0; i--) {
        if (num & 1 << i)
            printf("%d", 1);
        else
            printf("%d", 0);
        if (i % 8 == 0)
            printf(" ");
    }
    printf("\n");
}
```

## 2. C 高级

### 2.1 Makefile

Makefile 是一个用来**描述文件之间的依赖关系**的文件，Makefile 中包含了一组规则，这组规则告诉 make 命令如何去编译和链接程序。

Makefile 中包含了一组规则，每条规则的格式如下：

```makefile
target: prerequisites
    command
```

- target：目标文件，可以是目标文件、中间文件或者可执行文件。
- prerequisites：依赖文件，生成目标文件所需要的文件。
- command：命令，生成目标文件所需要执行的命令。

当依赖文件的修改时间晚于目标文件的修改时间时，才会执行命令。
`@command`：不显示命令本身，只显示命令执行结果。

Makefile 中的命令必须以**Tab**开头。

Makefile 中的变量：

- 宏定义：`NAME = value`
- 引用变量：`$(NAME)`

变量的定义语法形式：

```makefile
NAME = value # 延时赋值，只有在引用变量时才会展开
NAME := value # 立即赋值，定义时就会展开
NAME ?= value # 如果 NAME 没有被赋值，就赋值为 value
NAME += value # 追加赋值，将 value 追加到 NAME 的后面
```

Makefile 中的函数：

- `$(subst from,to,text)`：将 text 中的 from 替换为 to。
- `$(patsubst pattern,replacement,text)`：将 text 中符合模式 pattern 的部分替换为 replacement。
- `$(wildcard pattern)`：返回当前目录下所有符合模式 pattern 的文件名。
- `$(shell command)`：执行 shell 命令 command，并返回执行结果。

Makefile 中的条件判断：

```makefile
ifeq ($(NAME),value)
    command
else
    command
endif
```

Makefile 中的循环：

```makefile
for var in list
    command
endfor
```

Makefile 中的自动变量：

- `$@`：表示规则中的目标文件。
- `$<`：表示规则中的第一个依赖文件。
- `$^`：表示规则中的所有依赖文件。

通配符：

- `%`：匹配任意多个字符。
- `*`：匹配任意多个字符。
- `?`：匹配任意一个字符。
- `[characters]`：匹配 characters 中的任意一个字符。
- `[!characters]`：匹配除了 characters 中的任意一个字符。

Makefile 中的伪目标：

伪目标不是一个真正的目标，只是一个标签，用来执行一些特定的命令。防止目标文件和伪目标文件重名。

```makefile
.PHONY: clean
clean:
    rm -rf *.o
```

Makefile 中的隐含规则：

```makefile
# 将 main.c 编译为 main.o
main.o: main.c
    $(CC) -c main.c -o main.o
```

Makefile 中的模式规则：

```makefile
# 将所有的 .c 文件编译为 .o 文件
%.o: %.c
    $(CC) -c $< -o $@
```

Makefile 中的多目标规则：

```makefile
# 将 main.c 和 test.c 编译为 main.o 和 test.o
main.o test.o: main.c test.c
    $(CC) -c $< -o $@
```

Makefile 中的静态模式规则：

```makefile
# 将 main.c 和 test.c 编译为 main.o 和 test.o
main.o test.o: %.o: %.c
    $(CC) -c $< -o $@
```

## 3. 数据结构

### 3.1 什么是数据结构

数据：描述客观事物的符号，是计算机中可以操作的对象，是能被计算机识别，并输入给计算机处理的符号集合。

数据元素：组成数据的、有一定意义的基本单位，在计算机中通常作为整体处理。也被称为记录。

数据项：一个数据元素可以由若干个数据项组成，数据项是数据不可分割的最小单位。

数据对象：性质相同的数据元素的集合，是数据的子集。

数据结构：相互之间存在一种或多种特定关系的数据元素的集合。

数据结构指数据之间的相互关系，包含下面三方面的内容：

1. 逻辑结构：数据对象中数据元素之间的相互关系。
   - 集合结构：数据元素同属于一个集合。(散列表：哈希表)
   - 线性结构：数据元素之间存在一对一的关系。(线性表：数组、链表、队列、栈)
   - 树形结构：数据元素之间存在一对多的关系。(树：二叉树、堆、哈夫曼树)
   - 图形结构：数据元素之间存在多对多的关系。(图：有向图、无向图)
2. 物理结构：数据的逻辑结构在计算机中的存储形式。
   - 顺序存储结构：把数据元素存放在地址连续的存储单元里，其数据间的逻辑关系和物理关系是一致的。(顺序表：数组)
   - 链式存储结构：把数据元素存放在任意的存储单元里，这组存储单元可以是连续的，也可以是不连续的。(链表)
   - 索引存储结构：在存储数据的同时，还建立附加的索引表，通过索引表就可以找到存储数据的地址。(索引表)
   - 散列存储结构：根据关键字直接计算出该关键字对应的存储地址，将值存放在对应的地址中。(哈希表)
3. 数据运算：对数据元素可以施加的操作。(增删改查排序)

### 3.2 什么是算法

算法：解决问题的方法和步骤，是指令的有限序列，其中每一条指令表示一个或多个操作。

算法的特性：

- 有穷性：算法必须能在执行有限个步骤之后终止。
- 确定性：算法中的每一条指令必须有确切的含义，不会出现二义性。
- 可行性：算法的每一步都必须是可行的，也就是说每一步都能通过执行有限次数完成。
- 输入：一个算法有零个或多个输入。
- 输出：一个算法有一个或多个输出。

1. 空间复杂度：算法在运行过程中临时占用存储空间大小的量度。
2. 时间复杂度：算法执行时间随问题规模的增长而增长的量度。
   O(1) < O(logn) < O(n) < O(nlogn) < O(n^2) < O(n^3) < O(2^n) < O(n!) < O(n^n)

### 3.3 顺序表

顺序表：线性表的顺序存储结构，用一组地址连续的存储单元依次存储线性表的数据元素。

> 总结：
> 涉及插入先判满
> 涉及删除先判空
> 涉及位置先判断
> 涉及数据必遍历

```c
// 顺序表的结构
#define MAXSIZE 20 // 定义最大长度
typedef int elem_type; // 定义数据类型
typedef struct {
    elem_type data[MAXSIZE]; // 顺序表的元素
    int pos; // 顺序表的当前长度，也就是最后一个元素的下标。最初pos = -1，表示顺序表为空
}seqlist_t;
```

顺序表优缺点：

- 优点：无需为表中元素之间的逻辑关系增加额外的存储空间，可以快速的存取表中任一位置的元素。
- 缺点：插入和删除操作需要移动大量元素，当线性表长度变化较大时，难以确定存储空间的容量。

### 3.4 链表

链表：线性表的链式存储结构，用一组任意的存储单元存放线性表的数据元素。

#### 3.4.1 单链表

单链表：由节点组成，每个节点包括数据域和指针域，数据域存放数据元素，指针域存放下一个节点的地址。

> 总结：
> 1.if(pos) 控制 h 的指向始终是要操作位置的【前一位】
> 2.while() 控制 h 最远的合法指向：
> 先判断最后要操作的位置，尾结点用 h->next，NULL 结点用 h

```c
// 单链表的结构
typedef int elem_type;
typedef struct node {
    elem_type data; // 数据域
    struct node *next; // 指针域
}linklist_t;
```

```c
// 单链表逆序(头插法)
void linklist_reverse(linklist_t *head)
{
    linklist_t *p, *q; // p 为待插入节点，q 为临时节点
    p = head->next; // p 指向第一个节点
    head->next = NULL;
    while (p) {
        q = p->next; // 保存下一个节点
        p->next = head->next;
        head->next = p;
        p = q; // p 指向下一个节点
    }
}
```

```c
// 单链表排序(直接插入排序)
void linklist_sort(linklist_t *head)
{
    linklist_t *p, *q, *r; // p 为待插入节点，q 为插入位置，r 为临时节点
    p = head->next->next; // p 指向第二个节点
    head->next->next = NULL; // 将第一个节点单独拿出来
    while (p) {
        q = head;
        while (q->next && q->next->data < p->data) { // 寻找插入位置
            q = q->next;
        }
        r = p->next; // 保存下一个节点
        p->next = q->next;
        q->next = p;
        p = r; // p 指向下一个节点
    }
}
```

#### 3.4.2 单向循环链表

单向循环链表：单链表的最后一个节点指向头节点，形成一个环。

```c
// 单向循环链表的结构
typedef int elem_type;
typedef struct node {
    elem_type data; // 数据域
    struct node *next; // 指针域
}looplist_t;
```

#### 3.4.3 双链表

双链表：每个节点有两个指针域，分别指向前驱节点和后继节点。

```c
// 双链表的结构
typedef int elem_type;
typedef struct node {
    elem_type data; // 数据域
    struct node *prev, *next; // 前驱指针域，后继指针域
}dlinklist_t;
```

#### 3.4.4 双向循环链表

双向循环链表：双链表的最后一个节点的后继指针域指向头节点，头节点的前驱指针域指向尾节点。

```c
// 双向循环链表的结构
typedef int elem_type;
typedef struct node {
    elem_type data; // 数据域
    struct node *prev, *next; // 前驱指针域，后继指针域
}dlooplist_t;
```

### 3.5 栈

**栈和队列是限定操作的线性表。**

栈：限定仅在表尾进行插入和删除操作的线性表。表尾为栈顶，表头为栈底，不含元素的空表称为空栈。

栈分为顺序栈和链栈：

- 顺序栈：用顺序表实现的栈。
- 链栈：用链表实现的栈，头插、头删。

```c
// 顺序栈的结构
typedef int elem_type;
#define MAXSIZE 20
typedef struct {
    elem_type data[MAXSIZE]; // 数据域
    int top; // 栈顶指针
}seqstack_t;

// 链栈的结构
typedef int elem_type;
typedef struct node {
    elem_type data; // 数据域
    struct node *next; // 指针域
}linkstack_t;
```

### 3.6 队列

队列：限定仅在表头进行删除操作，在表尾进行插入操作的线性表。表头为队头，表尾为队尾，不含元素的空表称为空队列。

队列分为顺序队列和链队列：

- 顺序队列：用顺序表实现的队列，又分为循环队列和非循环队列。
- 链队列：用链表实现的队列，头插、尾删。

```c
// 顺序队列结构(基本不用)
typedef int elem_type;
#define MAXSIZE 20
typedef struct {
    elem_type data[MAXSIZE]; // 数据域
    int front, rear; // 队头指针，队尾指针
}seqqueue_t;

// 循环队列结构
typedef int elem_type;
#define MAXSIZE (20 + 1) // 多存储一个元素，用于区分队空和队满
typedef struct {
    elem_type data[MAXSIZE]; // 数据域
    int front, rear; // 队头指针，队尾指针
}loopqueue_t;
// 队空：front == rear
// 队满：(rear + 1) % MAXSIZE == front

// 链队列结构
typedef int elem_type;
typedef struct node {
    elem_type data; // 数据域
    struct node *next; // 指针域
}node_t;
// 链队列的头尾指针
typedef struct {
    node_t *front, *rear; // 队头指针，队尾指针
}linkqueue_t;
// 队空：front == rear
// 队满：无
// 队头出队，队尾入队
```

### 3.7 树

树：n(n >= 0) 个节点的有限集合，n = 0 时称为空树。在任意一棵非空树中:

- 有且仅有一个特定的称为根的节点。
- 当 n > 1 时，其余节点可分为 m(m > 0) 个互不相交的有限集 T1、T2、...、Tm，其中每个集合本身又是一棵树，并且称为根的子树。

树的基本术语：

- 节点的度：节点拥有的子树的个数。
- **树的度**：树中所有节点的度的最大值。
- 叶子节点：度为 0 的节点。
- 分支节点：度不为 0 的节点。
- 父节点：若一个节点含有子节点，则这个节点称为其子节点的父节点。
- 子节点：一个节点含有的子树的根节点称为该节点的子节点。
- 兄弟节点：具有相同父节点的节点互称为兄弟节点。
- 节点的层次：从根开始定义起，根为第一层，根的子节点为第二层，以此类推。
- **树的深度**：树中所有节点的最大层次。
- 节点的祖先：从根到该节点所经分支上的所有节点。
- 子孙：以某节点为根的子树中任一节点都称为该节点的子孙。
- 森林：由 m(m >= 0) 棵互不相交的树的集合称为森林。

树的存储结构：

- 双亲表示法：每个节点都有一个指示器指向其双亲节点。
- 孩子表示法：每个节点都有一个指示器指向其孩子节点。
- 孩子兄弟表示法：每个节点都有两个指示器，一个指向其第一个孩子节点，一个指向其右兄弟节点。

二叉树：每个节点最多有两个子树的树结构，称为二叉树。二叉树的子树有左右之分，次序不能颠倒。

二叉树的性质：

- 在二叉树的第 i 层上至多有 2^(i-1) 个节点。
- 深度为 k 的二叉树至多有 2^k - 1 个节点。
- 对任何一棵二叉树 T，如果其终端节点数为 n0，度为 2 的节点数为 n2，则 n0 = n2 + 1。
- 满二叉树：所有分支节点都存在左子树和右子树，并且所有叶子节点都在同一层上。
- 完全二叉树：对一棵具有 n 个节点的二叉树按层序编号，如果编号为 i(1 <= i <= n) 的节点与同样深度的满二叉树中编号为 i 的节点在二叉树中位置完全相同，则这棵二叉树称为完全二叉树。具有 n 个节点的完全二叉树的深度为 floor(log2n) + 1。

二叉树的存储结构：

- 顺序存储结构：有 n 个节点的完全二叉树可以用有 n+1 个元素的数组进行顺序存储，节点号和数组下标一一对应，下标为 0 的元素不用。将完全二叉树中的节点按层序编号，从 1 开始，根节点编号为 1，对于任意一个节点 i，其左孩子节点为 2i，右孩子节点为 2i+1，双亲节点为 floor(i/2)。不完全二叉树如果某节点的左孩子或右孩子不存在，则用 NULL 表示，这要浪费一些存储空间。
- 链式存储结构：每个节点包含三个域，一个数据域，一个左指针域，一个右指针域。

```c
// 二叉树的链式存储结构
typedef int elem_type;
typedef struct node {
    elem_type data; // 数据域
    struct node *lchild, *rchild; // 左右孩子指针域
}bitree_t;
```

二叉树的遍历：

- 广度优先遍历：按层次从上到下，从左到右的顺序遍历二叉树。
- 深度优先遍历：从根节点出发，按照某种次序依次访问二叉树中所有节点，使得每个节点被访问一次且仅被访问一次。(先序遍历、中序遍历、后序遍历)

### 3.8 总结

#### 3.8.1 顺序表

```c
// 顺序表结构体
#define datatype int
#define N 30
typedef struct{
    datatype data[N];
    int pos;
}seqlist_t;

// 顺序表创建
seqlist_t* SeqListCreate()
{
    seqlist_t* h = (seqlist_t*)malloc(sizeof(*h));
    if (!h) {
        printf("%s malloc seqlist error\n", __func__);
        return NULL;
    }
    h->pos = -1;
    return h;
}
// 判满
int SeqListIsFull(seqlist_t* h)
{
    return h->pos + 1 == N ? 1 : 0;
}
// 插入
int SeqListInsertData(seqlist_t* h, datatype data)
{
    if (SeqListIsFull(h))
        PRINT_ERR("full");
    h->data[++h->pos] = data;
    return 0;
}
// 遍历
void SeqListShow(seqlist_t* h)
{
    for (int i = 0; i <= h->pos; i++) {
        printf("-%d", h->data[i]);
    }
  printf("\n");
}
// 判空
int SeqListIsEmpty(seqlist_t* h)
{
    return h->pos == -1 ? 1 : 0;
}
// 删除
datatype SeqListDeleteData(seqlist_t* h)
{
    if (SeqListIsEmpty(h))
        PRINT_ERR("empty");
    return h->data[h->pos--];
}
// 按位插
int SeqListInsertByPos(seqlist_t* h, int pos, datatype data)
{
    if (SeqListIsFull(h))
        PRINT_ERR("full");
    if (pos < 0 || pos > h->pos + 1)
        PRINT_ERR("pos error");
    for (int i = h->pos; i >= pos; i--) {
        h->data[i + 1] = h->data[i];
    }
    h->data[pos] = data;
    h->pos++;
    return 0;
}
// 按位删
datatype SeqListDeleteByPos(seqlist_t* h, int pos)
{
    if (SeqListIsEmpty(h))
        PRINT_ERR("empty");
    if (pos < 0 || pos > h->pos)
        PRINT_ERR("pos error");
    datatype data = h->data[pos];
    for (int i = pos; i < h->pos; i++) {
        h->data[i] = h->data[i + 1];
    }
    h->pos--;
    return data;
}
// 按位查数
datatype SeqListCheckDataByPos(seqlist_t* h, int pos)
{
    if (pos < 0 || pos > h->pos)
        PRINT_ERR("pos error");
    return h->data[pos];
}
// 按数查位
int SeqListCheckPosByData(seqlist_t* h, datatype data)
{
    for (int i = 0; i <= h->pos; i++) {
        if (h->data[i] == data)
            return i;
    }
    PRINT_ERR("data error");
}
// 按位更数
int SeqListUpdataDataByPos(seqlist_t* h, int pos, datatype ndata)
{
    if (pos < 0 || pos > h->pos)
        PRINT_ERR("pos error");
    h->data[pos] = ndata;
    return 0;
}
// 按数更数
int SeqListUpdataDataByData(seqlist_t* h, datatype data, datatype ndata)
{
    for (int i = 0; i <= h->pos; i++) {
        if (h->data[i] == data) {
            h->data[i] = ndata;
            return 0;
        }
    }
    printf("%s data error\n", __func__);
    return -1;
}
```

#### 3.8.2 单链表

排序(直接插入排序)

```c
// 单链表结构体
#define datatype int
typedef struct node {
    datatype data;
    struct node* next;
} linklist_t;

// 单链表创建
linklist_t* LinkListCreate()
{
    linklist_t* h = (linklist_t*)malloc(sizeof(*h));
    if (!h) {
        printf("%s linklist malloc error\n", __func__);
        return NULL;
    }
    h->data = (datatype)0;
    h->next = NULL;
    return h;
}
// 头插
int LinkListInsertHead(linklist_t* h, datatype data)
{
    linklist_t* temp = (linklist_t*)malloc(sizeof(*temp));
    if (!temp)
        PRINT_ERR("malloc error");
    temp->data = data;
    temp->next = h->next;
    h->next = temp;
    return 0;
}
// 尾插
int LinkListInsertTail(linklist_t* h, datatype data)
{
    linklist_t* temp = (linklist_t*)malloc(sizeof(*temp));
    if (!temp)
        PRINT_ERR("malloc error");
    while (h->next)
        h = h->next;
    temp->data = data;
    temp->next = h->next;
    h->next = temp;
    return 0;
}
// 位置插
int LinkListInsertByPos(linklist_t* h, int pos, datatype data)
{
    if (pos < 0)
        PRINT_ERR("left pos error");
    while (h) {
        if (pos) {
            h = h->next;
            pos--;
        } else {
            linklist_t* temp = (linklist_t*)malloc(sizeof(*temp));
            if (!temp)
                PRINT_ERR("malloc error");
            temp->data = data;
            temp->next = h->next;
            h->next = temp;
            return 0;
        }
    }
    PRINT_ERR("right pos error");
}
// 判空
int LinkListIsEmpty(linklist_t* h)
{
    return h->next == NULL ? 1 : 0;
}
// 头删
datatype LinkListDeleteHead(linklist_t* h)
{
    if (LinkListIsEmpty(h)) {
        printf("%s linklist empty error\n", __func__);
        return (datatype)-1;
    }
    linklist_t* temp = h->next;
    datatype data = temp->data;
    h->next = temp->next;
    if (temp) {
        free(temp);
        temp = NULL;
    }
    return data;
}
// 尾删
datatype LinkListDeleteTail(linklist_t* h)
{
    if (LinkListIsEmpty(h)) {
        printf("linklist empty error\n", __func__);
        return (datatype)-1;
    }
    while (h->next->next)
        h = h->next;
    linklist_t* temp = h->next;
    datatype data = temp->data;
    h->next = temp->next;
    if (temp) {
        free(temp);
        temp = NULL;
    }
    return data;
}
// 位置删
datatype LinkListDeleteByPos(linklist_t* h, int pos)
{
    if (LinkListIsEmpty(h)) {
        printf("linklist empty error\n", __func__);
        return (datatype)-1;
    }
    if (pos < 0) {
        printf("%s left pos erron\n", __func__);
        return (datatype)-1;
    }
    while (h->next) {
        if (pos) {
            h = h->next;
            pos--;
        } else {
            linklist_t* temp = h->next;
            datatype data = temp->data;
            h->next = temp->next;
            if (temp) {
                free(temp);
                temp = NULL;
            }
            return data;
        }
    }
    printf("%s right pos error\n", __func__);
    return (datatype)-1;
}
// 按位查
datatype LinkListCheckByPos(linklist_t* h, int pos)
{
    if (pos < 0) {
        printf("%s left pos error\n", __func__);
        return (datatype)-1;
    }
    while (h->next) {
        if (pos) {
            h = h->next;
            pos--;
        } else {
            return h->next->data;
        }
    }
    printf("%s right pos error\n", __func__);
    return (datatype)-1;
}
// 按位改
int LinkListUpdataByPos(linklist_t* h, int pos, datatype ndata)
{
    if (pos < 0)
        PRINT_ERR("left pos error");
    while (h->next) {
        if (pos) {
            h = h->next;
            pos--;
        } else {
            h->next->data = ndata;
            return 0;
        }
    }
    PRINT_ERR("right pos error");
}
// 遍历
void LinkListShow(linklist_t* h)
{
    while (h->next) {
        h = h->next;
        printf("->%d", h->data);
    }
    printf("\n");
}
// 反转(头插法)
void LinkListReversion(linklist_t* h)
{
    linklist_t *move, *temp = h->next;
    h->next = NULL;
    while (temp) {
        move = temp;
        temp = temp->next;
        move->next = h->next;
        h->next = move;
    }
}
// 排序(直接插入排序)
void LinkListInsertSort(linklist_t* h)
{
    linklist_t *move, *th = h, *temp = h->next;
    h->next = NULL;
    while (temp) {
        move = temp;
        temp = temp->next;
        while ((h->next) && (move->data > h->next->data)) {
            h = h->next;
        }
        move->next = h->next;
        h->next = move;
        h = th;
    }
}
```

#### 3.8.3 单向循环链表

```c
// 单向循环链表结构体
#define datatype int
typedef struct node {
    datatype data;
    struct node* next;
} looplist_t;

// 单向循环链表创建
looplist_t* LoopListCreate()
{
    looplist_t* h = (looplist_t*)malloc(sizeof(*h));
    if (!h) {
        printf("%s malloc error\n", __func__);
        return NULL;
    }
    h->data = (datatype)0;
    h->next = h;
    return h;
}
// 头插
int LoopListInsertHead(looplist_t* h, datatype data)
{
    looplist_t* temp = (looplist_t*)malloc(sizeof(*temp));
    if (!temp)
        PRINT_ERR("malloc error");
    temp->data = data;
    temp->next = h->next;
    h->next = temp;
    return 0;
}
// 尾插
int LoopListInsertTail(looplist_t* h, datatype data)
{
    looplist_t* temp = (looplist_t*)malloc(sizeof(*temp));
    if (!temp)
        PRINT_ERR("malloc error");
    looplist_t* th = h;
    while (h->next != th)
        h = h->next;
    temp->data = data;
    temp->next = h->next;
    h->next = temp;
    return 0;
}
// 位置插
int LoopListInsertByPos(looplist_t* h, int pos, datatype data)
{
    if (pos < 0)
        PRINT_ERR("left pos error");
    looplist_t* th = h;
    while (h->next != th || pos == 0) {
        if (pos) {
            h = h->next;
            pos--;
        } else {
            looplist_t* temp = (looplist_t*)malloc(sizeof(*temp));
            if (!temp)
                PRINT_ERR("malloc error");
            temp->data = data;
            temp->next = h->next;
            h->next = temp;
            return 0;
        }
    }
    PRINT_ERR("right pos error");
}
// 判空
int LoopListIsEmpty(looplist_t* h)
{
    return h->next == h ? 1 : 0;
}
// 头删
datatype LoopListDeleteHead(looplist_t* h)
{
    if (LoopListIsEmpty(h)) {
        printf("%s empty error\n", __func__);
        return (datatype)-1;
    }
    looplist_t* temp = h->next;
    datatype data = temp->data;
    h->next = temp->next;
    if (temp) {
        free(temp);
        temp = NULL;
    }
    return data;
}
// 尾删
datatype LoopListDeleteTail(looplist_t* h)
{
    if (LoopListIsEmpty(h)) {
        printf("%s empty error\n", __func__);
        return (datatype)-1;
    }
    looplist_t* th = h;
    while (h->next->next != th) {
        h = h->next;
    }
    looplist_t* temp = h->next;
    datatype data = temp->data;
    h->next = temp->next;
    if (temp) {
        free(temp);
        temp = NULL;
    }
    return data;
}
// 位置删
datatype LoopListDeleteByPos(looplist_t* h, int pos)
{
    if (LoopListIsEmpty(h)) {
        printf("%s empty error\n", __func__);
        return (datatype)-1;
    }
    if (pos < 0) {
        printf("%s left pos erron\n", __func__);
        return (datatype)-1;
    }
    looplist_t* th = h;
    while (h->next != th) {
        if (pos) {
            h = h->next;
            pos--;
        } else {
            looplist_t* temp = h->next;
            datatype data = temp->data;
            h->next = temp->next;
            if (temp) {
                free(temp);
                temp = NULL;
            }
            return data;
        }
    }
    printf("%s right pos error\n", __func__);
    return (datatype)-1;
}
// 按位查
datatype LoopListCheckByPos(looplist_t* h, int pos)
{
    if (pos < 0) {
        printf("%s left pos error\n", __func__);
        return (datatype)-1;
    }
    looplist_t* th = h;
    while (h->next != th) {
        if (pos) {
            h = h->next;
            pos--;
        } else {
            return h->next->data;
        }
    }
    printf("%s right pos error\n", __func__);
    return (datatype)-1;
}
// 按位改
int LoopListUpdataByPos(looplist_t* h, int pos, datatype ndata)
{
    if (pos < 0)
        PRINT_ERR("left pos error");
    looplist_t* th = h;
    while (h->next != th) {
        if (pos) {
            h = h->next;
            pos--;
        } else {
            h->next->data = ndata;
            return 0;
        }
    }
    PRINT_ERR("right pos error");
}
// 遍历
void LoopListShow(looplist_t* h)
{
    looplist_t* th = h;
    while (h->next != th) {
        h = h->next;
        printf("->%d", h->data);
    }
    printf("\n");
}
// 去头
looplist_t* LoopListCutHead(looplist_t* h)
{
    looplist_t* th = h;
    if (h->next = th) {
        printf("%s looplist empty error\n", __func__);
        return NULL;
    }
    while (h->next != th)
        h = h->next;
    h->next = th->next;
    if (th) {
        free(th);
        th = NULL;
    }
    // 返回新头结点(首元结点)
    return h->next;
}
// 无头单向循环链表遍历
void LoopListNoHeadShow(looplist_t* h)
{
    if (!h)  // 因为无头，所以必须判空，否则后面h->next段错误
        return;
    looplist_t* th = h;
    while (h->next != th) {
        printf("->%d", h->data);
        h = h->next;
    }
    // 当只有一个结点时，直接输出
    // 当多个结点时，输出最后一个
    printf("->%d\n", h->data);
}
```

#### 3.8.4 双链表

```c
// 双链表结构体
#define datatype int
typedef struct node {
    datatype data;
    struct node *pre, *next;
} dlinklist_t;

// 双链表创建
dlinklist_t* DLinkListCreate()
{
    dlinklist_t* h = (dlinklist_t*)malloc(sizeof(*h));
    if (!h) {
        printf("%s malloc error\n", __func__);
        return NULL;
    }
    h->data = (datatype)0;
    h->pre = h->next = NULL;
    return h;
}
// 头插
int DLinkListInsertHead(dlinklist_t* h, datatype data)
{
    dlinklist_t* temp = (dlinklist_t*)malloc(sizeof(*temp));
    if (!h)
        PRINT_ERR("malloc error");
    temp->data = data;
    temp->next = h->next;
    temp->pre = h;
    h->next = temp;
    if (temp->next) {
        temp->next->pre = temp;
    }
    return 0;
}
// 尾插
int DLinkListInsertTail(dlinklist_t* h, datatype data)
{
    dlinklist_t* temp = (dlinklist_t*)malloc(sizeof(*temp));
    if (!h)
        PRINT_ERR("malloc error");
    while (h->next)
        h = h->next;
    temp->data = data;
    temp->next = h->next;
    temp->pre = h;
    h->next = temp;
    return 0;
}
// 位置插
int DLinkListInsertByPos(dlinklist_t* h, int pos, datatype data)
{
    if (pos < 0)
        PRINT_ERR("left pos error");
    while (h) {
        if (pos) {
            h = h->next;
            pos--;
        } else {
            dlinklist_t* temp = (dlinklist_t*)malloc(sizeof(*temp));
            if (!h)
                PRINT_ERR("malloc error");
            temp->data = data;
            temp->next = h->next;
            temp->pre = h;
            h->next = temp;
            if (temp->next) {
                temp->next->pre = temp;
            }
            return 0;
        }
    }
    PRINT_ERR("right pos error");
}
// 判空
int DLinkListIsEmpty(dlinklist_t* h)
{
    return h->next == NULL ? 1 : 0;
}
// 头删
datatype DLinkListDeleteHead(dlinklist_t* h)
{
    if (DLinkListIsEmpty(h)) {
        printf("%s empty error\n", __func__);
        return (datatype)-1;
    }
    dlinklist_t* temp = h->next;
    datatype data = temp->data;
    h->next = temp->next;
    if (temp->next)
        temp->next->pre = h;
    if (temp) {
        free(temp);
        temp = NULL;
    }
    return data;
}
// 尾删
datatype DLinkListDeleteTsil(dlinklist_t* h)
{
    if (DLinkListIsEmpty(h)) {
        printf("%s empty error\n", __func__);
        return (datatype)-1;
    }
    while (h->next->next)
        h = h->next;
    dlinklist_t* temp = h->next;
    datatype data = temp->data;
    h->next = temp->next;
    if (temp) {
        free(temp);
        temp = NULL;
    }
    return data;
}
// 位置删
datatype DLinkListDeleteByPos(dlinklist_t* h, int pos)
{
    if (DLinkListIsEmpty(h)) {
        printf("%s empty error\n", __func__);
        return (datatype)-1;
    }
    if (pos < 0) {
        printf("%s left pos error\n", __func__);
        return (datatype)-1;
    }
    while (h->next) {
        if (pos) {
            h = h->next;
            pos--;
        } else {
            dlinklist_t* temp = h->next;
            datatype data = temp->data;
            h->next = temp->next;
            if (temp->next)
                temp->next->pre = h;
            if (temp) {
                free(temp);
                temp = NULL;
            }
            return data;
        }
    }
    printf("%s right pos error\n", __func__);
    return (datatype)-1;
}
// 按位查
datatype DLinkListCheckByPos(dlinklist_t* h, int pos)
{
    if (pos < 0) {
        printf("%s left pos error\n", __func__);
        return (datatype)-1;
    }
    while (h->next) {
        if (pos) {
            h = h->next;
            pos--;
        } else {
            return h->next->data;
        }
    }
    printf("%s right pos error\n", __func__);
    return (datatype)-1;
}
// 按位改
int DLinkListUpdataByPos(dlinklist_t* h, int pos, datatype ndata)
{
    if (pos < 0) {
        printf("%s left pos error\n", __func__);
        return -1;
    }
    while (h->next) {
        if (pos) {
            h = h->next;
            pos--;
        } else {
            h->next->data = ndata;
            return 0;
        }
    }
    printf("%s right pos error\n", __func__);
    return -1;
}
// 遍历
void DLinkListShow(dlinklist_t* h)
{
    printf("head:");
    while (h->next) {
        h = h->next;
        printf("->%d", h->data);
    }
    printf("\n");
    printf("tail:");
    while (h->pre) { // h!=th;
        printf("->%d", h->data);
        h = h->pre;
    }
    printf("\n");
}
// 反转
void DLinkListReversion(dlinklist_t* h)
{
    if (!h->next) { //需要判空，因为有temp->next
        return;
    }
    dlinklist_t *tmp, *temp = h->next;
    while (temp->next) {
        tmp = h->next;
        h->next = h->pre;
        h->pre = tmp;
        temp = temp->pre;
    }
    temp->next = temp->pre;
    temp->pre = h;
    h->next->next = NULL;
    h->next = temp;
}
```

#### 3.8.5 双向循环链表

```c
// 双向循环链表结构体
#define datatype int
typedef struct node {
    datatype data;
    struct node *pre, *next;
} dlooplist_t;

// 双向循环链表创建
dlooplist_t* DLoopListCreate()
{
    dlooplist_t* h = (dlooplist_t*)malloc(sizeof(*h));
    if (!h) {
        printf("%s malloc error\n", __func__);
        return NULL;
    }
    h->data = (datatype)0;
    h->next = h->pre = h;
    return h;
}
// 头插
int DLoopListInsertHead(dlooplist_t* h, datatype data)
{
    dlooplist_t* temp = (dlooplist_t*)malloc(sizeof(*temp));
    if (!temp)
        PRINT_ERR("malloc error");
    temp->data = data;
    temp->next = h->next;
    temp->pre = h;
    h->next = temp;
    temp->next->pre = temp;
    return 0;
}
// 尾插
int DLoopListInsertTail(dlooplist_t* h, datatype data)
{
    dlooplist_t* th = h;
    dlooplist_t* temp = (dlooplist_t*)malloc(sizeof(dlooplist_t));
    if (!temp) {
        printf("%s malloc error\n", __func__);
        return -1;
    }
    while (h->next != th)
        h = h->next;
    temp->data = data;
    temp->next = h->next;
    temp->pre = h;
    h->next = temp;
    temp->next->pre = temp;
    return 0;
}
// 位置插
int DLoopListInsertByPos(dlooplist_t* h, int pos, datatype data)
{
    if (pos < 0) {
        printf("%s left pos error\n", __func__);
        return -1;
    }
    dlooplist_t* th = h;
    dlooplist_t* temp = (dlooplist_t*)malloc(sizeof(dlooplist_t));
    if (!temp) {
        printf("%s malloc error\n", __func__);
        return -1;
    }
    while (h->next != th || pos == 0) {
        if (pos) {
            h = h->next;
            pos--;
        } else {
            temp->data = data;
            temp->next = h->next;
            temp->pre = h;
            h->next = temp;
            temp->next->pre = temp;
            return 0;
        }
    }
    printf("%s right pos error\n", __func__);
    return -1;
}
// 判空
int DLoopListIsEmpty(dlooplist_t* h)
{
    return h->next == h ? 1 : 0;
}
// 头删
datatype DLoopListDeleteHead(dlooplist_t* h)
{
    if (DLoopListIsEmpty(h)) {
        printf("%s is empty\n", __func__);
        return (datatype)-1;
    }
    dlooplist_t* temp = h->next;
    datatype data = temp->data;
    h->next = temp->next;
    temp->next->pre = h;
    if (temp) {
        free(temp);
        temp = NULL;
    }
    return data;
}
// 尾删
datatype DLoopListDeleteTail(dlooplist_t* h)
{
    if (DLoopListIsEmpty(h)) {
        printf("%s empty error\n", __func__);
        return (datatype)-1;
    }
    dlooplist_t* th;
    while (h->next->next != th) {
        h = h->next;
    }
    dlooplist_t* temp = h->next;
    datatype data = temp->data;
    h->next = temp->next;
    temp->next->pre = h;
    if (temp) {
        free(temp);
        temp = NULL;
    }
    return data;
}
// 位置删
datatype DLoopListDeleteByPos(dlooplist_t* h, int pos)
{
    if (DLoopListIsEmpty(h)) {
        printf("%s empty error\n", __func__);
        return (datatype)-1;
    }
    if (pos < 0) {
        printf("%s left pos error\n", __func__);
        return (datatype)-1;
    }
    dlooplist_t* th = h;
    while (h->next != th) {
        if (pos) {
            h = h->next;
            pos--;
        } else {
            dlooplist_t* temp = h->next;
            datatype data = temp->data;
            h->next = temp->next;
            temp->next->pre = h;
            if (temp) {
                free(temp);
                temp = NULL;
            }
            return data;
        }
    }
    printf("%s right pos error\n", __func__);
    return (datatype)-1;
}
// 按位查
datatype DLoopListCheckDataByPos(dlooplist_t* h, int pos)
{
    dlooplist_t* th = h;
    if (pos < 0) {
        printf("%s left pos error\n", __func__);
        return (datatype)-1;
    }
    while (h->next != th) {
        if (pos) {
            h = h->next;
            pos--;
        } else {
            return h->next->data;
        }
    }
    printf("%s right pos error\n", __func__);
    return (datatype)-1;
}
// 按位改
int DLoopListUpdateDataByPos(dlooplist_t* h, int pos, datatype ndata)
{
    dlooplist_t* th = h;
    if (pos < 0) {
        printf("%s left pos error\n", __func__);
        return -1;
    }
    while (h->next != th) {
        if (pos) {
            h = h->next;
            pos--;
        } else {
            h->next->data = ndata;
            return 0;
        }
    }
    printf("%s right pos error\n", __func__);
    return (datatype)-1;
}
// 遍历
void DLoopListShow(dlooplist_t* h)
{
    dlooplist_t* th = h;
    printf("head:");
    while (h->next != th) {
        h = h->next;
        printf("%d->", h->data);
    }
    printf("\n");
    printf("tail:");
    while (h != th) {
        printf("%d->", h->data);
        h = h->pre;
    }
    printf("\n");
}
```

#### 3.8.6 栈

顺序栈:

```c
//顺序栈结构体
#define datatype int
#define N 10
typedef struct
{
  datatype data[N];
  int top; //栈的数据进出只能通过top控制(数组最后元素的下标)
}seqstack_t;

// 顺序栈的创建
seqstack_t* SeqStackCreate(void)
{
    seqstack_t* h = (seqstack_t*)malloc(sizeof(seqstack_t));
    if (!h) {
        printf("%s malloc error\n", __func__);
        return NULL;
    }
    memset(h, 0, sizeof(seqstack_t));
    h->top = -1;
    return h;
}
// 判满
int SeqStackIsFull(seqstack_t* h)
{
    return h->top + 1 == N ? 1 : 0;
}
// 入栈
int SeqStackPush(seqstack_t* h, datatype data)
{
    if (SeqStackIsFull(h)) {
        printf("%s is full,push error\n", __func__);
        return -1;
    }
    h->data[++h->top] = data;
    return 0;
}
// 判空
int SeqStackIsEmpty(seqstack_t* h)
{
    return h->top == -1 ? 1 : 0;
}
// 出栈
datatype SeqStackPop(seqstack_t* h)
{
    if (SeqStackIsEmpty(h)) {
        printf("%s is empty,pop error\n", __func__);
        return (datatype)-1;
    }
    return h->data[h->top--];
}
// 遍历
void SeqStackShow(seqstack_t* h)
{
    for (int i = 0; i <= h->top; i++) {
        printf("%d-", h->data[i]);
    }
    printf("\n");
}
```

链式栈:

```c
//链式栈结构体
#define datatype int
typedef struct node
{
  datatype data;
  struct node *next;
} linkstack_t;

// 创建链式栈
linkstack_t* LinkStackCreate()
{
    linkstack_t* h = (linkstack_t*)malloc(sizeof(linkstack_t));
    if (!h) {
        printf("%s malloc error\n", __func__);
        return NULL;
    }
    h->data = (datatype)0;
    h->next = NULL;
    return h;
}
// 入栈（头插法）
int LinkStackPush(linkstack_t* h, datatype data)
{
    linkstack_t* temp = (linkstack_t*)malloc(sizeof(linkstack_t));
    if (!temp) {
        printf("%s malloc error\n", __func__);
        return -1;
    }
    temp->data = data;
    temp->next = h->next;
    h->next = temp;
    return 0;
}
// 判空
int LinkStackEmpty(linkstack_t* h)
{
    return h->next == NULL ? 1 : 0;
}
// 出栈（头删法）
datatype LinkStackPop(linkstack_t* h)
{
    if (LinkStackEmpty(h)) {
        printf("%s is empty,pop error\n", __func__);
        return (datatype)-1;
    }
    linkstack_t* temp = h->next;
    datatype data = temp->data;
    h->next = temp->next;
    if (temp) {
        free(temp);
        temp = NULL;
    }
    return data;
}
// 遍历
void LinkStackShow(linkstack_t* h)
{
    while (h->next) {
        h = h->next;
        printf("%d->", h->data);
    }
    printf("\n");
}
```

#### 3.8.7 队列

循环队列:

==判满：(rear+1) % QueueSize = front
入队：front = (front+1) % QueueSize
长度：(rear - front + QueueSize) % QueueSize==

```c
// 循环队列结构体
#define datatype int
#define N 5
typedef struct {
    datatype data[N+1]; //循环队列数组要多一个用来判满
    int front,rear; //front队头，rear队尾(标记计数)
}loopqueue_t;

loopqueue_t* LoopQueueCreate(void)
{
    loopqueue_t* h = (loopqueue_t*)malloc(sizeof(loopqueue_t));
    if (!h) {
        printf("%s memory error\n", __func__);
        return NULL;
    }
    memset(h, 0, sizeof(*h));
    h->rear = h->front = 0; // 初始化队列没有数据,都在下标为0的位置
    return h;
}
// 判满
int LoopQueueIsFull(loopqueue_t* h)
{
    return (h->rear + 1) % (N + 1) == h->front ? 1 : 0;
}
// 入队
int LoopQueueEnQueue(loopqueue_t* h, datatype data)
{
    if (LoopQueueIsFull(h)) {
        printf("%s is full,enter queue error\n", __func__);
        return -1;
    }
    h->data[h->rear] = data;
    h->rear = (h->rear + 1) % (N + 1);
    return 0;
}
// 判空
int LoopQueueIsEmpty(loopqueue_t* h)
{
    return h->rear == h->front ? 1 : 0;
}
// 出队
datatype LoopQueueDeQueue(loopqueue_t* h)
{
    if (LoopQueueIsEmpty(h)) {
        printf("%s is empty,delete queue error\n", __func__);
        return (datatype)-1;
    }
    datatype data = h->data[h->front];
    //h->data[h->front] = 0; // 为了遍历显示,实际不需要
    h->front = (h->front + 1) % (N + 1);
    return data;
}
// 遍历(只是遍历数组)
void LoopQueueShow(loopqueue_t* h)
{
    for (int i = 0; i < N + 1; i++) {
        printf("%d-", h->data[i]);
    }
    printf("\n");
}
```

链式队列:

```c
//链式队列结构体
#define datatype int
typedef struct node {
    datatype data;
    struct node* next;
} node_t;
typedef struct {
    node_t *front, *rear;
} linkqueue_t;

//// 创建链式队列
linkqueue_t *LinkQueueCreate(void)
{
  node_t *h = (node_t *)malloc(sizeof(node_t));
  if (!h)
  {
    printf("%s malloc node memory error\n", __func__);
    return NULL;
  }
  linkqueue_t *q = (linkqueue_t *)malloc(sizeof(linkqueue_t));
  if (!q)
  {
  printf("%s malloc link point memory error\n", __func__);
  return NULL;
  }
  h->data = (datatype)0;
  h->next = NULL;
  q->front = q->rear = h;

  return q;
}
// 入队
int LinkQueueEnQueue(linkqueue_t *q, datatype data)
{
  node_t *temp = (node_t *)malloc(sizeof(node_t));
  if (!temp)
  {
    printf("%s malloc error\n", __func__);
    return -1;
  }
  temp->data = data;
  temp->next = q->rear->next;
  q->rear->next = temp;
  q->rear = temp;
  return 0;
}
// 判空
int LinkQueueIsEmpty(linkqueue_t *q)
{
  return q->rear == q->front ? 1 : 0;
}
// 出队
datatype LinkQueueDeQeueue(linkqueue_t *q)
{
  if (LinkQueueIsEmpty(q))
  {
    printf("%s empty queue error\n", __func__);
    return (datatype)-1;
  }
  node_t *temp = q->front->next;
  datatype data = temp->data;
  q->front->next = temp->next;
  if (!temp->next)
  { // 只有一个结点
    q->rear = q->front;
  }
  if (temp)
  {
    free(temp);
    temp = NULL;
  }
  return data;
}
// 遍历
void LinkQueueShow(linkqueue_t *q)
{
  node_t *temp = q->front;
  while (temp->next)
  {
    temp = temp->next;
    printf("%d->", temp->data);
  }
  printf("\n");
}
```

#### 3.8.8 树

```c
//二叉树结构体
#define datatype int
typedef struct node_t {
    datatype data;
    struct node_t *lchild, *rchild;
} bitree_t;

// 普通二叉树创建(叶子结点用#补全)(只能先序创建)
bitree_t* BiTreeNormalCreate()
{
    char ch;
    ch = getchar();
    if (ch == '#') {
        return NULL;
    }
    bitree_t* root = (bitree_t*)malloc(sizeof(bitree_t));
    if (!root) {
        printf("%s malloc error\n", __func__);
        return NULL;
    }
    root->data = ch; // 不管写在什么位置都不影响递归，只能是先序遍历输入
    root->lchild = BiTreeNormalCreate();
    // root->data=ch;
    root->rchild = BiTreeNormalCreate();
    // root->data=ch;
    return root;
}

//创建完全二叉树
//n 树中结点的个数，i树中结点的编号(根)，n>=1
bitree_t* BiTreeCompleteCreate(int n, datatype i)
{
    bitree_t* root = (bitree_t*)malloc(sizeof(bitree_t));
    if (!root) {
        printf("%s malloc node memory error\n", __func__);
        return NULL;
    }
    root->data = i;
    if (2 * i <= n) {
        root->lchild = BiTreeCompleteCreate(n, 2 * i);
    } else {
        root->lchild = NULL;
    }
    if (2 * i + 1 <= n) {
        root->rchild = BiTreeCompleteCreate(n, 2 * i + 1);
    } else {
        root->rchild = NULL;
    }
    return root;
}

//广度优先遍历(用链式队列)
//先入队(根节点)
LinkQueueEnQueue(q,(datatype)root);
bitree_t* temp;
//二叉树循环出队入队，当队为空时遍历结束，跳出循环
while(!LinkQueueIsEmpty(q)){
    //出队
    temp=(bitree_t*)LinkQueueDeQeueue(q);
    //访问树结点的数据
    printf("%d ",temp->data);
    //判断是否有左右孩子，如果有入队(出一个入两个)
    //如果没有实际只循环上面的语句，直到队空
    if(temp->lchild){
        LinkQueueEnQueue(q,(datatype)temp->lchild);
    }
    if(temp->rchild){
        LinkQueueEnQueue(q,(datatype)temp->rchild);
    }
}
printf("\n");

//深度优先遍历
// 前序遍历
void BiTreeFrontOrder(bitree_t* root)
{
    if (!root) {
        return; // 递归出口，必须要写
    }
    printf("%c ", root->data);
    BiTreeFrontOrder(root->lchild);
    BiTreeFrontOrder(root->rchild);
}
// 中序遍历
void BiTreeMiddleOrder(bitree_t* root)
{
    if (!root) {
        return;
    }
    BiTreeMiddleOrder(root->lchild);
    printf("%c ", root->data);
    BiTreeMiddleOrder(root->rchild);
}
// 后序遍历
void BiTreeRearOrder(bitree_t* root)
{
    if (!root) {
        return;
    }
    BiTreeRearOrder(root->lchild);
    BiTreeRearOrder(root->rchild);
    printf("%c ", root->data);
}
```

### 3.9 算法

#### 3.9.1 快速排序

```c
// 快速排序
void QuickSort(int* arr, int left, int right)
{
    if (left >= right) { // 递归出口
        return;
    }
    int i = left, j = right, key = arr[left]; // 选取第一个数为基准数
    while (i < j) { // 从左右两边交替扫描，直到 i=j 为止
        while (i < j && arr[j] >= key) { // 从右向左找第一个小于key的值
            j--;
        }
        arr[i] = arr[j];
        while (i < j && arr[i] <= key) { // 从左向右找第一个大于key的值
            i++;
        }
        arr[j] = arr[i];
    }
    arr[i] = key; // i=j 将基准数放入正确位置
    QuickSort(arr, left, i - 1);
    QuickSort(arr, i + 1, right);
}
```

时间复杂度：O(nlogn)，最坏情况下为 O(n^2)

#### 3.9.2 冒泡排序

```c
// 冒泡排序
void BubbleSort(int* arr, int n)
{
    int i, j, temp;
    for (i = 0; i < n - 1; i++) { // n 个数排序，只用进行 n-1 趟
        for (j = 0; j < n - 1 - i; j++) { // 每趟比较次数递减
            if (arr[j] > arr[j + 1]) { // 相邻元素比较，若逆序则交换(升序)
                temp = arr[j];
                arr[j] = arr[j + 1];
                arr[j + 1] = temp;
            }
        }
    }
}
```

时间复杂度：O(n^2)

#### 3.9.3 Hash 查找

Hash 表：数组+链表

Hash 查找：通过计算关键字的存储地址，直接访问存储位置，查找速度快。Hash 查找的基本思想是：将关键字通过一个函数(Hash 函数)转换为一个存储地址，将记录存储在该地址上。Hash 函数的构造方法有很多，常用的有直接定址法、数字分析法、平方取中法、折叠法、除留余数法、随机数法等。Hash 查找的优点是查找速度快，其缺点是需要消耗较多的存储空间，且不能按关键字大小有序地遍历记录。

## 4. IO 进程线程

### 4.1 系统调用与库函数

系统调用：系统调用是操作系统提供给用户程序使用的一种服务，由于用户程序不能直接访问操作系统，所以必须通过系统调用接口来向操作系统发出服务请求，用户程序通过系统调用接口调用相应的系统调用函数，从而向操作系统发出服务请求，系统调用函数将用户程序提供的参数传递给操作系统，操作系统完成服务后，再将结果返回给用户程序。**不同的操作系统系统调用的接口是不相同的**。

库函数：库函数=缓冲区+系统调用，库函数本身就是为了解决系统调用不兼容而设计的，所以库函数的可执行性比较强。由于库函数有缓冲区，所以库函数的效率比较高。

posix 标准：posix 标准是为了解决不同操作系统的系统调用不兼容而设计的，posix 标准是一种接口标准，不是具体的实现，所以不具有可执行性。

### 4.2 标准 IO

标准 IO：标准 IO 是对系统调用的封装，是一种库函数，是一种缓冲 IO，是一种行 IO，是一种面向文件的 IO，是一种同步 IO。

**缓冲区是为了提高效率和避免频繁的系统调用。**缓冲区分为全缓冲、行缓冲、无缓冲。全缓冲是指填满缓冲区后才进行 IO 操作，行缓冲是指遇到换行符后才进行 IO 操作，无缓冲是指不使用缓冲区，直接进行 IO 操作。

**同步 IO 是指用户进程发起 IO 操作后，必须等待 IO 操作完成后才能进行下一步操作。**同步 IO 有阻塞 IO 和非阻塞 IO。阻塞 IO 是指用户进程发起 IO 操作后，必须等待 IO 操作完成后才能进行下一步操作，非阻塞 IO 是指用户进程发起 IO 操作后，不必等待 IO 操作完成就可以进行下一步操作。

**异步 IO 是指用户进程发起 IO 操作后，不必等待 IO 操作完成就可以进行下一步操作。**异步 IO 有信号驱动 IO 和多路复用 IO。信号驱动 IO 是指用户进程发起 IO 操作后，不必等待 IO 操作完成就可以进行下一步操作，当 IO 操作完成后，会向用户进程发送一个信号，多路复用 IO 是指用户进程发起 IO 操作后，不必等待 IO 操作完成就可以进行下一步操作，当 IO 操作完成后，可以通过 select 函数来判断 IO 操作是否完成。

FILE 结构体：FILE 结构体是对文件的抽象。

```c
typedef struct _IO_FILE FILE;

struct _IO_FILE {
    int _flags; //打开文件的方式
    char* _IO_buf_base; //缓冲区的起始地址
    char* _IO_buf_end; //缓冲区的结束地址
    int _fileno;  //文件描述符，和系统调用相关 (fd)
};
```

在一个正在执行的程序中有三个可以直接使用的 FILE 结构体：stdin,stdout,stderr。它们分别代表标准输入、标准输出和标准错误输出。

相关函数：

```c
#include <stdio.h> //标准 IO 头文件

/**
 * @brief 打开文件
 * @param filename 文件名
 * @param mode 打开方式
 *        r: 只读 r+: 读写 如果文件不存在则报错
 *        w: 只写 w+: 读写 如果文件不存在则创建，如果文件存在则清空
 *        a: 追加 a+: 读写 如果文件不存在则创建，如果文件存在则在文件末尾追加
 *        光标位置: 如果是 r, r+, w, w+ 光标在文件的开头，如果是 a, a+ 光标在文件的结尾
 * @return 文件指针
 */
FILE* fopen(const char* filename, const char* mode);

/**
 * @brief 关闭文件
 * @param stream 文件指针
 * @return 0: 成功 -1: 失败
 */
int fclose(FILE* stream);

/**
 * @brief 读取文件
 * @param ptr 读取的内容存放的地址
 * @param size 每次读取的字节数
 * @param nmemb 读取的次数
 * @param stream 文件指针
 * @return 读取的次数
 */
size_t fread(void* ptr, size_t size, size_t nmemb, FILE* stream);

/**
 * @brief 写入文件
 * @param ptr 写入的内容存放的地址
 * @param size 每次写入的字节数
 * @param nmemb 写入的次数
 * @param stream 文件指针
 * @return 写入的次数
 */
size_t fwrite(const void* ptr, size_t size, size_t nmemb, FILE* stream);

/**
 * @brief 读取一行
 * @param str 读取的内容存放的地址
 * @param size 读取的字节数
 * @param stream 文件指针
 * @return 读取的内容存放的地址
 */
char* fgets(char* str, int size, FILE* stream);

/**
 * @brief 写入一行
 * @param str 写入的内容存放的地址
 * @param stream 文件指针
 * @return 0: 成功 -1: 失败
 */
int fputs(const char* str, FILE* stream);

/**
 * @brief 获取文件指针的位置
 * @param stream 文件指针
 * @return 文件指针的位置
 */
long ftell(FILE* stream);

/**
 * @brief 设置文件指针的位置
 * @param stream 文件指针
 * @param offset 偏移量
 * @param whence 偏移的起始位置
 *        SEEK_SET: 文件的开头
 *        SEEK_CUR: 文件指针的位置
 *        SEEK_END: 文件的结尾
 * @return 0: 成功 -1: 失败
 */
int fseek(FILE* stream, long offset, int whence);

/**
 * @brief 将文件指针设置到文件的开头
 * @param stream 文件指针
 * @return 0: 成功 -1: 失败
 */
void rewind(FILE* stream);

/**
 * @brief 格式化输出
 * @param stream 文件指针
 * @param format 格式化字符串
 * @return 0: 成功 -1: 失败
 */
int fprintf(FILE* stream, const char* format, ...);

/**
 * @brief 格式化输入
 * @param stream 文件指针
 * @param format 格式化字符串
 * @return 0: 成功 -1: 失败
 */
int fscanf(FILE* stream, const char* format, ...);

/**
 * @brief 格式化输出
 * @param str 输出的内容存放的地址
 * @param size 输出的字节数
 * @param format 格式化字符串
 * @return 0: 成功 -1: 失败
 */
int snprintf(char* str, size_t size, const char* format, ...);

/**
 * @brief 获取当前时间的秒数
 * @param t 秒数存放的地址
 * @return 秒数
 */
time_t time(time_t* t);

/**
 * @brief 将秒数转换为时间
 * @param t 秒数
 * @return 时间结构体指针
 */
struct tm* localtime(const time_t* t);
// 时间结构体
struct tm {
    int tm_sec; // 秒
    int tm_min; // 分
    int tm_hour; // 时
    int tm_mday; // 日
    int tm_mon; // 月
    int tm_year; // 年
    int tm_wday; // 星期
    int tm_yday; // 一年中的第几天
    int tm_isdst; // 夏令时
};

/**
 * @brief 刷新缓冲区
 * @param stream 文件指针
 * @return 0: 成功 -1: 失败
 */
int fflush(FILE* stream);
```

### 4.3 标准 IO 缓冲区

- 全缓冲：和**文件**相关的操作，就是全缓冲(FILE\* fp)。(大小 4KB)
  5 种方式会将缓冲区的内容写入文件：缓冲区满了，调用 fflush()，调用 fclose(fp)，输入输出发生切换、程序结束。
- 行缓冲：和**终端**相关的操作，就是行缓冲(stdin，stdout)。(大小 1KB)
  6 种方式会将缓冲区的内容写入终端：遇到换行符，缓冲区满了，调用 fflush()，调用 fclose(stdout)，输入输出发生切换、程序结束。
- 无缓冲：**标准出错**对应的是无缓冲(stderr)。(大小 0KB)
  每次调用都会立即输出。

### 4.4 文件 IO

文件 IO 是系统调用，不是库函数，不使用缓冲区，直接调用系统内核。

fd：文件描述符，是一个非负整数，是内核为了高效管理已经打开的文件所创建的索引，**每个进程都有自己的文件描述符表**，当打开或创建一个文件时，内核向进程返回一个文件描述符。其中 0,1,2 分别是标准输入、标准输出、标准错误输出。

fd 文件描述符其实就是 fd_array 数组的下标，fd_array 数组的每个元素都是一个 file 结构体，file 结构体中有一个 file_operations 结构体指针，这个结构体中有 open、read、write、close 等函数指针，这些函数指针指向的是驱动程序中的对应函数，这样就实现了用户程序和驱动程序的交互。

```c
#include <sys/types.h> // 文件描述符
#include <sys/stat.h> // 文件权限
#include <fcntl.h> // 文件操作

/**
 * @brief 打开文件
 * @param pathname 文件路径
 * @param flags 打开方式
 *        O_RDONLY: 只读
 *        O_WRONLY: 只写
 *        O_RDWR: 读写
 *        O_CREAT: 文件不存在则创建
 *        O_EXCL: 与 O_CREAT 一起使用，文件存在则报错
 *        O_TRUNC: 文件存在则清空
 *        O_APPEND: 追加
 *        O_NONBLOCK: 非阻塞，只对设备文件有效
 * @param mode 权限，只有在创建文件时才有效
 * @return 文件描述符
 */
int open(const char* pathname, int flags, mode_t mode);

/**
 * @brief 关闭文件
 * @param fd 文件描述符
 * @return 0: 成功 -1: 失败
 */
int close(int fd);

/**
 * @brief 读取文件
 * @param fd 文件描述符
 * @param buf 读取内容存放的地址
 * @param count 读取的字节数
 * @return 读取的字节数
 */
ssize_t read(int fd, void* buf, size_t count);

/**
 * @brief 写入文件
 * @param fd 文件描述符
 * @param buf 写入内容存放的地址
 * @param count 写入的字节数
 * @return 写入的字节数
 */
ssize_t write(int fd, const void* buf, size_t count);

/**
 * @brief 移动文件指针
 * @param fd 文件描述符
 * @param offset 偏移量
 * @param whence 偏移的起始位置
 *        SEEK_SET: 文件起始位置
 *        SEEK_CUR: 当前位置
 *        SEEK_END: 文件末尾
 * @return 移动后的位置
 */
off_t lseek(int fd, off_t offset, int whence);
```

### 4.5 文件属性

```c
#include <sys/types.h>
#include <sys/stat.h>
#include <unistd.h>

/**
 * @brief 获取文件属性
 * @param pathname 文件路径
 * @param statbuf 文件属性存放的地址
 * @return 0: 成功 -1: 失败
 */
int stat(const char* pathname, struct stat* statbuf);
struct stat {
    dev_t st_dev; // 设备编号
    ino_t st_ino; // i 节点号
    mode_t st_mode; // 文件类型和权限
    nlink_t st_nlink; // 硬链接数
    uid_t st_uid; // 用户 id
    gid_t st_gid; // 组 id
    dev_t st_rdev; // 设备类型
    off_t st_size; // 文件大小
    blksize_t st_blksize; // 块大小
    blkcnt_t st_blocks; // 块数
    time_t st_atime; // 最后访问时间
    time_t st_mtime; // 最后修改时间
    time_t st_ctime; // 最后状态改变时间
};

#include <pwd.h>
#include <grp.h>

/**
 * @brief 根据uid获取用户的信息
 * @param uid 用户 id
 * @return 用户信息
 */
struct passwd* getpwuid(uid_t uid);
struct passwd {
    char* pw_name; // 用户名
    char* pw_passwd; // 密码
    uid_t pw_uid; // 用户 id
    gid_t pw_gid; // 组 id
    char* pw_gecos; // 用户全名
    char* pw_dir; // 用户主目录
    char* pw_shell; // 用户 shell
};****

/**
 * @brief 根据gid获取组的信息
 * @param gid 组 id
 * @return 组信息
 */
struct group* getgrgid(gid_t gid);
struct group {
    char* gr_name; // 组名
    char* gr_passwd; // 密码
    gid_t gr_gid; // 组 id
    char** gr_mem; // 组成员
};
```

### 4.6 目录操作

```c
#include <sys/types.h>
#include <dirent.h>

/**
 * @brief 打开目录
 * @param pathname 目录路径
 * @return 目录指针
 */
DIR* opendir(const char* pathname);

/**
 * @brief 读取目录
 * @param dir 目录指针
 * @return 目录项指针
 */
struct dirent* readdir(DIR* dir);
struct dirent {
    ino_t d_ino; // inode 节点号
    char d_name[]; // 文件名
};

/**
 * @brief 关闭目录
 * @param dir 目录指针
 * @return 0: 成功 -1: 失败
 */
int closedir(DIR* dir);
```

### 4.7 库的制作及使用

> Linux 下静态库的制作与使用：
>
> 1. gcc -c test.c -o test.o
> 2. ar -crs libtest.a test.o
> 3. gcc main.c -static -ltest -L ./
>
> Linux 下动态库的制作与使用：
>
> 1. gcc -shared -fpic test.c -o libtest.so
> 2. gcc main.c -ltest -L ./
> 3. 将 test.so 添加到 /lib 目录下

一般工程目录结构：

```shell
.
├── inc
│   └── test.h
├── lib
│   ├── libtest.a
│   └── libtest.so
├── src
│   ├── test.c
│   └── main.c
├── bin
│   └── a.out
└── Makefile
```

Makefile 文件：

```makefile
# 编译器
CC = gcc
# 编译选项
CFLAGS = -Wall -g
# 头文件路径
INC = -I../inc
# 库文件路径
LIB = -L../lib
# 库文件
LIBS = -ltest
# 目标文件
TARGET = a.out
# 源文件
SRCS = main.c test.c
# 目标文件
OBJS = $(SRCS:.c=.o)

# 生成目标文件
$(OBJS): %.o: %.c
    $(CC) $(CFLAGS) $(INC) -c $< -o $@

# 生成可执行文件
$(TARGET): $(OBJS)
    $(CC) $(CFLAGS) $(LIB) $(LIBS) $^ -o $@

# 清理
clean:
    rm -rf $(OBJS) $(TARGET)
```

### 4.8 进程

#### 4.8.1 进程的概念

进程：进程是一个正在执行的程序，是一个动态的概念，是资源分配的最小单位。每一个进程都会分配自己的 0-3G 的内存空间，0-3G 的内存空间有多份，而 **3-4G 内核空间只有一份**。进程是内核创建的，每个进程都有一个唯一的进程号，进程号是一个非负整数，_进程号为 0 的进程是调度进程，进程号为 1 的进程是 init 进程_。进程的状态有：运行态、就绪态、阻塞态。进程的状态转换：就绪态 -> 运行态、运行态 -> 就绪态、运行态 -> 阻塞态、阻塞态 -> 就绪态。**每个进程在内核空间都有一个 task_struct 结构体**，这个结构体中存储了进程的所有信息。正在运行的进程会被放到一个运行队列中，随着**时间片轮询**依次来执行进程。一个进程的崩溃不会影响另外一个进程的执行，进程的安全性高。

操作系统通过 MMU(内存映射单元) 来管理内存，MMU 通过页表来管理内存。每个进程都有自己的页表，页表中存储了虚拟地址和物理地址的映射关系(将物理内存映射出虚拟内存)。**进程的切换是通过修改页表来实现的，进程切换时会将当前进程的页表切换到内核空间(将当前进程的堆栈段切换到内核空间)，然后再将下一个进程的页表切换到内核空间，最后再将下一个进程的页表切换到用户空间。**

swap 分区：swap 分区是一块磁盘空间，当物理内存不足时，会将内存中的数据写入到 swap 分区中，当需要使用时再从 swap 分区中读取到内存中。swap 分区的大小一般是物理内存的两倍。

#### 4.8.2 进程的组成

PCB(进程控制块 task_struct)：**PCB 是操作系统中的一个概念，task_struct 是 Linux 内核中的一个结构体，是 PCB 的具体实现。**

进程的组成：

- PCB：存储了进程的所有信息(PID)
- 数据段：存放程序运行时候产生的数据
- 代码段：存放可执行程序的代码

#### 4.8.3 进程的种类

- 交互进程：由 shell 创建维护的进程，可以与用户进行交互。
- 守护进程：是由内核创建的，是后台进程，不会与用户进行交互，一般用于系统服务。
- 批处理进程：批处理进程的优先级比较低，通常情况下批处理进程都会被放到队列中执行，例如 gcc 编译程序的过程就是批处理进程。

#### 4.8.4 PID

PID：进程号，在 linux 系统上所有的进程都可以在/proc 目录下查看。PPID 是进程的父进程号。在一个系统上可以通过如下命令查看能创建的最大进程的个数：`cat /proc/sys/kernel/pid_max`，可以通过如下命令查看当前系统上的进程个数：`ps -ef | wc -l`。

特殊的进程：

- idle 进程：进程号为 0 的进程，是调度进程，在 linux 系统启动的时候最先运行的进程就是 0 号进程，0 号进程又叫空闲进程。**如果系统上没有其他进程执行那么 0 号进程就执行。**0 号进程是 1 号进程和 2 号进程的父进程。
- init 进程：进程号为 1 的进程，是初始化进程，init 进程是由 0 号进程创建得到的，**它的主要工作是系统的初始化。当初始化工作执行完之后，它主要负责回收孤儿进程的资源。**
- kthreadd 进程：进程号为 2 的进程，是调度器进程，kthreadd 是由 0 号进程创建出来的，**它主要负责调度工作。**

#### 4.8.5 进程相关 shell 命令

- ps：查看进程信息

  1. `ps -ef`：查看所有进程信息
     UID：进程的用户 ID
     PID：进程号
     PPID：父进程号
     C：CPU 占用率
     STIME：进程启动时间
     TTY：进程所在的终端
     TIME：进程运行的时间
     CMD：进程名
  2. `ps -ajx`：查看所有进程信息，包括进程的状态(**一般使用这条命令查看**，查看到的进程的信息更完全)
     PPID：父进程号
     PID：进程号
     PGID：进程组号，进程组又分为前台进程组和后台进程组，**前台进程组只有一个，后台进程组有多个**
     SID：会话号，**在 linux 系统上新开一个终端就会默认创建一个会话**，一个会话包含多个进程组，一个进程组包含多个进程
     TTY：进程所在的终端，**如果是问号，说明没有终端与之对应**
     TPGID：进程组号，**如果是-1 就是守护进程**
     STAT：进程的状态
     UID：进程的用户 ID，0 表示 root 用户 1000 表示普通用户
     TIME：进程运行的时间
     COMMAND：进程名

- top/htop：查看进程信息，**top 命令是实时刷新的**，htop 是 top 命令的升级版，**htop 命令是实时刷新的，而且可以使用鼠标进行交互**
- kill：给进程发信号
  1. `kill -9 进程号`：给进程发送 kill 信号，**默认是 TERM 信号，kill -9 是强制杀死进程**
  2. `kill -l`：查看所有的信号

#### 4.8.6 进程的状态

| 状态 | 说明                                   |
| :--- | :------------------------------------- |
| R    | 运行状态                               |
| S    | 可中断的等待态(sleep,可被信号打断)     |
| D    | 不可中断的等待态(sleep,不可被信号打断) |
| Z    | 僵尸态                                 |
| T    | 停止态                                 |
| X    | 死亡态                                 |
| I    | 空闲态                                 |

| 附加态 | 说明                     |
| :----- | :----------------------- |
| <      | 高优先级的进程           |
| N      | 低优先级的进程           |
| L      | 有些页被锁住(锁在内存上) |
| s      | 进程的领导者(会话组长)   |
| +      | 位于前台的进程组         |
| l      | 多线程的进程(包含多线程) |

孤儿进程：父进程先于子进程结束，子进程就会变成孤儿进程，孤儿进程会被 init 进程接管，init 进程会回收孤儿进程的资源。
僵尸进程：如果子进程先于父进程结束，父进程没有回收子进程的资源，子进程就会变成僵尸进程，僵尸进程会一直占用系统资源，直到父进程回收子进程的资源。

进程的五状态模型：

- 运行态：进程正在运行
- 就绪态：进程已经准备好了，等待 CPU 调度
- 等待态(阻塞态)：进程正在等待某个事件的发生
- 新建态：进程正在被创建，通常是 task_struct 已经创建但是还没有加载到内存中
- 终止态：进程已经结束，但是还没有被回收

#### 4.8.7 进程状态切换

- `ctrl + c`：终止进程(发送 (2)INT 信号)
- `ctrl + z`：挂起进程(发送 (20)TSTP 信号)
- `jobs -l`：查看所有的后台进程
- `fg %进程号`：将后台进程切换到前台
- `bg %进程号`：将前台进程切换到后台
- `kill -9 进程号`：杀死进程(发送 (9)KILL 信号)

#### 4.8.8 进程的优先级

- nice：查看进程的优先级
- renice：修改进程的优先级

#### 4.8.9 进程 API

```c
/**
 * @brief 创建进程
 * @return 成功返回子进程的进程号(父进程PID+1)，失败返回-1
 * @note fork() 函数会返回两次，父进程返回子进程的进程号，子进程返回 0
 * @note 如果创建子进程失败，fork() 函数会返回 -1
 * @note 子进程会复制父进程的所有资源，包括堆栈段，所以两个进程都停留在fork函数中等待返回，最终返回两次。会适当修改里面的内容，例如修改pid和ppid等等。(写时拷贝)
*/
pid_t fork(void);
// 父子进程执行没有先后顺序，时间片轮询，上下文切换

/**
 * @brief 结束当前进程(库函数，会刷新缓冲区)
 * @param status 退出状态
 *        EXIT_SUCCESS 0：正常退出
 *        EXIT_FAILURE 1：异常退出
*/
void exit(int status);

/**
 * @brief 结束当前进程(系统调用，不会刷新缓冲区)
 * @param status 退出状态
 *        EXIT_SUCCESS 0：正常退出
 *        EXIT_FAILURE 1：异常退出
*/
void _exit(int status);

/**
 * @brief 等待子进程退出，回收子进程的资源
 * @param status 用于获取子进程的退出状态
 * @return 成功返回子进程的进程号，失败返回-1
 * @note 如果有多个子进程，会等待任意一个子进程退出，哪个子进程先结束wait就回收哪个进程的资源
 * WIFEXITED(status)：如果子进程正常退出，返回非0值
 * WEXITSTATUS(status)：获取子进程的退出状态(status >> 8 & 0xff)
 * WIFSIGNALED(status)：如果子进程是因为信号而退出，返回非0值
 * WTERMSIG(status)：获取子进程的信号编号(status & 0x7f)
*/
pid_t wait(int *status);

/**
 * @brief 等待指定的进程退出，回收进程的资源
 * @param pid 指定的子进程的进程号
 *        pid > 0：等待指定的子进程退出
 *        pid == -1：等待任意一个子进程退出，不管当前进程是否和父进程同组，父进程都能回收它的资源
 *        pid == 0：等待和当前进程组id相同的任意一个子进程退出
 *        pid < -1：首先对pid取绝对值，回收和绝对值相等的同组的进程的资源
 * @param status 用于获取子进程的退出状态
 * @param options 选项
 *        0：阻塞等待子进程退出
 *        WNOHANG：如果没有子进程退出，立即返回，不会阻塞
 * @return 成功返回子进程的进程号，如果是非阻塞的，没有子进程退出，返回0，失败返回-1
*/
pid_t waitpid(pid_t pid, int *status, int options);

/**
 * @brief 获取当前进程的进程号
 * @return 当前进程的进程号
*/
pid_t getpid(void);

/**
 * @brief 获取当前进程的父进程的进程号
 * @return 当前进程的父进程的进程号
*/
pid_t getppid(void);

/**
 * @brief 获取当前进程的用户id
 * @return 当前进程的用户id
*/
uid_t getuid(void);

/**
 * @brief 获取当前进程的组id
 * @return 当前进程的组id
*/
gid_t getgid(void);
```

#### 4.8.10 守护进程创建流程

1. 创建孤儿进程(父进程退出，子进程继续运行)
2. 设置孤儿进程的会话 id(setsid)

   ```c
   /**
    * @brief 设置孤儿进程的会话 id
    * @return 成功返回新的会话id，失败返回-1
   */
    pid_t setsid(void);
   ```

3. 修改当前的工作目录为根目录(chdir)

   ```c
   /**
    * @brief 修改当前的工作目录为根目录
    * @param path 要修改的工作目录
    * @return 成功返回0，失败返回-1
   */
    int chdir(const char *path);
   ```

4. 重设文件权限掩码(umask)

   ```c
    /**
     * @brief 重设文件权限掩码
     * @param mask 新的文件权限掩码
     * @return 返回原来的文件权限掩码
    */
     mode_t umask(mode_t mask);
   ```

5. 创建打开日志文件

   ```c
   int fd = open("daemon.log", O_RDWR | O_CREAT | O_APPEND | O_EXCL, 0664);
   if (fd == -1) {
       perror("open error");
       exit(1);
   }
   ```

6. 重定向文件描述符

   ```c
   /**
    * @brief 重定向文件描述符
    * @param oldfd 要重定向的文件描述符
    * @param newfd 重定向后的文件描述符
    * @return 成功返回新的文件描述符，失败返回-1
   */
    int dup2(int oldfd, int newfd);

    dup2(fd, STDIN_FILENO);  /* Standard input. 0 */
    dup2(fd, STDOUT_FILENO);  /* Standard output. 1 */
    dup2(fd, STDERR_FILENO);  /* Standard error output. 2 */
   ```

7. 开启守护进程

#### 4.8.11 进程内程序的替换

思考终端上如何执行 a.out 程序：

1. 终端输入 a.out
2. 系统调用 fork 创建子进程
3. 子进程调用 exec 函数族执行 a.out 程序

```c
/**
 * @brief 在c程序中执行一条命令
 * @param command 要执行的命令
 * @return 成功返回0，失败返回-1
*/
int system(const char *command);
```

### 4.9 进程间通信(7 种)

#### 4.9.1 传统进程间通信方式

##### 4.9.1.1 无名管道

无名管道是一种半双工的通信方式，只能在具有公共祖先的两个进程之间使用，一般用于父子进程之间通信。(**亲缘进程**)

**无名管道的读写特点**：

- 读端不存在写管道：进程收到管道破裂的信号(SIGPIPE)，默认终止进程
- 写端不存在读管道：一直读，直到读完管道中的数据，读端返回 0
- 读端存在(不读)写管道：一直写，直到写满管道(**64KB**)，写进程阻塞
- 写端存在(不写)读管道：一直读，直到读完管道中的数据，读进程阻塞

```c
/**
 * @brief 创建无名管道
 * @param fd 用于获取管道的读写文件描述符
 *        fd[0]：读端
 *        fd[1]：写端
 * @return 成功返回0，失败返回-1
*/
int pipe(int fd[2]);
```

管道都无法使用 lseek 函数，因为管道是半双工的，只能读或者写，不能同时读写。

##### 4.9.1.2 有名管道

有名管道是一种半双工的通信方式，可以在具有公共祖先的两个进程之间使用，也可以在没有公共祖先的两个进程之间使用。(**任意进程**)

有名管道创建之后会在用户空间创建一个管道文件，该文件的大小为 0，因为管道文件只是用来标识管道的存在，管道的数据是在内核空间中的。该文件的 i 节点中的 nlink 为 2，因为该文件有两个链接，一个是用户创建的，一个是内核创建的。

**有名管道的读写特点**：

- 读端不存在写管道：
  - 读端没有打开，写端在 open 的位置阻塞
  - 读端先打开后关闭，写管道进程收到管道破裂的信号(SIGPIPE)，默认终止进程
- 写端不存在读管道：
  - 写端没有打开，读端在 open 的位置阻塞
  - 写端先打开后关闭，读管道一直读，直到读完管道中的数据，读端返回 0
- 读端存在(不读)写管道：一直写，直到写满管道(**64KB**)，写进程阻塞
- 写端存在(不写)读管道：一直读，直到读完管道中的数据，读进程阻塞

```c
/**
 * @brief 创建有名管道
 * @param pathname 管道文件的路径名
 * @param mode 管道文件的权限 (mode & ~umask)
 * @return 成功返回0，失败返回-1
*/
int mkfifo(const char *pathname, mode_t mode);
```

##### 4.9.1.3 信号

信号是一种异步通信方式，用于通知接收进程某个事件已经发生。信号的发送和接收都是通过内核来完成的。

一个进程在执行的时候用户可以通过 kill 命令或者操作系统给当前的进程发送信号，进程可以通过 signal 函数来注册信号处理函数，当进程接收到信号时，会调用信号处理函数来处理信号。

**进程对当前的信号的响应方式：默认，忽略，捕捉**

> 在所有的信号中，SIGKILL 和 SIGSTOP 不能被捕捉和忽略，只能使用默认方式。

SIGCHLD(17): 子进程终止或者停止时，父进程会收到该信号

信号的发送方式：`kill -信号编号 PID`

```c
/**
 * @brief 注册信号处理函数
 * @param signum 信号编号
 * @param handler 信号处理函数
 *        SIG_DFL：默认处理方式
 *        SIG_IGN：忽略信号
 *        函数指针：捕捉信号(信号处理函数)
 * @return 成功返回函数指针，失败返回 SIG_ERR，置位错误码
*/
typedef void (*sighandler_t)(int);
sighandler_t signal(int signum, sighandler_t handler);


/**
 * @brief 给当前进程发送信号
 * @param signum 信号编号
 * @return 成功返回0，失败返回-1
*/
int raise(int signum); // 向当前进程发送信号

/**
 * @brief 发送信号
 * @param pid 进程的pid
 *        pid > 0：发送给指定的进程
 *        pid = 0：发送给同一进程组的所有进程
 *        pid = -1：发送给除了1号进程(init)的所有进程
 *        pid < -1：发送给指定进程组的所有进程
 * @param signum 信号编号
 * @return 成功返回0，失败返回-1
*/
int kill(pid_t pid, int signum);

/**
 * @brief 休眠指定的秒数，当 seconds 秒到达时，会给当前进程发送 SIGALRM 信号
 * @param seconds 秒数，如果为 0，会取消之前的闹钟
 * @return 如果之前设置了闹钟，返回之前闹钟的剩余秒数，如果之前没有设置闹钟，返回 0
 * @note alarm(5);  //返回值是0
 *       sleep(2);  //延时2s
 *       alarm(5);  //返回值是3
*/
unsigned int alarm(unsigned int seconds);
```

#### 4.9.2 system V 进程间通信方式

system V: AT&T Bell Labs 的 UNIX 第五版

查看 IPC(Inter-Process Communication)(进程间通信)的命令：`ipcs`

- 消息队列: `ipcs -q`
- 共享内存: `ipcs -m`
- 信号量: `ipcs -s`

删除 IPC 的命令：`ipcrm`

- 消息队列: `ipcrm -q msqid`
- 共享内存: `ipcrm -m shmid`
- 信号量: `ipcrm -s semid`

```c
/**
 * @brief 获取 IPC 的标识符
 * @param pathname 用于生成 key 的文件路径名
 * @param proj_id 用于生成 key 的整数(只有低8bit有效)
 * @return 成功返回 key，失败返回 -1
 * @note 生成的 key 用于创建 IPC
*/
key_t ftok(const char *pathname, int proj_id);
```

##### 4.9.2.1 消息队列

消息队列是一种**面向记录**的通信方式，消息队列中的每条消息都有一个类型，接收进程可以根据消息的类型来接收消息。

如果想要使用消息队列实现进程间通信，就必须**在内核空间创建出来消息队列**，消息队列默认大小是 16384(16K)，当创建好消息队列之后 A 进程可以向消息队列中发消息，消息的格式是类型+正文。当消息队列满的时候 A 进程如果还想往消息队列中发消息 A 进程休眠。B 进程可以通过消息的类型从消息队列中取消息，取出的消息从队列中移除。如果 B 进程想要获取的消息类型在队列中不存在 B 进程休眠等。

```c
/**
 * @brief 创建或者获取消息队列
 * @param key 用于创建消息队列的 key，通过 ftok 函数生成
 *        IPC_PRIVATE：只能用于亲缘关系的进程间通信
 * @param msgflg 创建消息队列的标志
 *        IPC_CREAT：如果不存在则创建，存在则获取
 *        IPC_EXCL：如果不存在则创建，存在则报错
 * @return 成功返回消息队列的标识符，失败返回 -1
*/
int msgget(key_t key, int msgflg);

/**
 * @brief 向消息队列中发送消息
 * @param msqid 消息队列的标识符
 * @param msgp 消息的地址
 *       struct msgbuf {
 *          long mtype;       // 消息的类型
 *          char mtext[256];    // 消息的正文
 *       };
 * @param msgsz 消息的大小
 * @param msgflg 发送消息的标志
 *        0：如果消息队列满了，休眠等待
 *        IPC_NOWAIT：如果消息队列满了，不等待直接返回
 * @return 成功返回0，失败返回-1
*/
int msgsnd(int msqid, const void *msgp, size_t msgsz, int msgflg);

/**
 * @brief 从消息队列中接收消息
 * @param msqid 消息队列的标识符
 * @param msgp 消息的地址
 *       struct msgbuf {
 *          long mtype;       // 消息的类型
 *          char mtext[256];    // 消息的正文
 *       };
 * @param msgsz 消息的大小
 * @param msgtyp 消息的类型
 *        0：接收消息队列中的第一条消息
 *        >0：接收消息队列中的第一条类型为 msgtyp 的消息
 *        <0：接收消息队列中的第一条类型小于等于 msgtyp 绝对值的消息
 * @param msgflg 接收消息的标志
 *        0：如果消息队列空了，休眠等待
 *        IPC_NOWAIT：如果消息队列空了，不等待直接返回
 * @return 成功返回消息的大小，失败返回-1
*/
ssize_t msgrcv(int msqid, void *msgp, size_t msgsz, long msgtyp, int msgflg);

/**
 * @brief 控制消息队列
 * @param msqid 消息队列的标识符
 * @param cmd 控制命令
 *        IPC_STAT：获取消息队列的状态
 *        IPC_SET：设置消息队列的状态
 *        IPC_RMID：删除消息队列。唤醒所有等待的读取器和写入器进程(返回一个错误并将errno设置为EIDRM)。调用进程必须具有适当的特权，或者它的有效用户ID必须是消息队列的创建者或所有者的ID。在这种情况下，msgctl()的第三个参数将被忽略。
 * @param buf 消息队列的状态(属性)
 *        struct msqid_ds {
 *          struct ipc_perm msg_perm;    // 消息队列的权限
 *          time_t msg_stime;            // 最后一次发送消息的时间
 *          time_t msg_rtime;            // 最后一次接收消息的时间
 *          time_t msg_ctime;            // 最后一次变更消息队列的时间
 *          unsigned long msg_cbytes;    // 消息队列中的字节数
 *          msgqnum_t msg_qnum;            // 消息队列中的消息数
 *          msglen_t msg_qbytes;            // 消息队列的最大字节数
 *          pid_t msg_lspid;            // 最后一次发送消息的进程ID
 *          pid_t msg_lrpid;            // 最后一次接收消息的进程ID
 *        };
 *        struct ipc_perm {
 *          uid_t uid;    // 消息队列的所有者的有效用户ID
 *          gid_t gid;    // 消息队列的所有者的有效组ID
 *          uid_t cuid;    // 消息队列的创建者的有效用户ID
 *          gid_t cgid;    // 消息队列的创建者的有效组ID
 *          mode_t mode;    // 消息队列的访问权限
 *          unsigned short seq;    // 序列号
 *        };
 * @return 成功返回0，失败返回-1
*/
int msgctl(int msqid, int cmd, struct msqid_ds *buf);
```

##### 4.9.2.2 共享内存

共享内存是所有进程间通信方式中**效率最高**的一个，因为当创建共享内存之后，需要通信的 A 和 B 进程可以直接操作这块物理内存空间，省去了向内核拷贝数据的过程。共享内存的大小是 4K 的整数倍，因为内存页的大小是 4K，一次最少分配一个内存页。

```c
/**
 * @brief 创建或者获取共享内存
 * @param key 用于创建共享内存的 key，通过 ftok 函数生成
 *        IPC_PRIVATE：只能用于亲缘关系的进程间通信
 * @param size 创建共享内存的大小，4k的整数倍
 * @param shmflg 创建共享内存的标志
 *        IPC_CREAT：如果不存在则创建，存在则获取
 *        IPC_EXCL：如果不存在则创建，存在则报错
 * @return 成功返回共享内存的标识符，失败返回 -1
*/
int shmget(key_t key, size_t size, int shmflg);

/**
 * @brief 映射共享内存到进程的虚拟地址空间
 * @param shmid 共享内存的标识符
 * @param shmaddr 映射的地址，通常设置为 NULL，让系统自动分配
 * @param shmflg 映射共享内存的标志
 *        0：读写映射
 *        SHM_RDONLY：只读映射
 * @return 成功返回映射的地址，失败返回 -1
*/
void *shmat(int shmid, const void *shmaddr, int shmflg);

/**
 * @brief 解除共享内存的映射
 * @param shmaddr 映射的地址
 * @return 成功返回 0，失败返回 -1
*/
int shmdt(const void *shmaddr);

/**
 * @brief 控制共享内存
 * @param shmid 共享内存的标识符
 * @param cmd 控制命令
 *        IPC_STAT：获取共享内存的状态
 *        IPC_SET：设置共享内存的状态
 *        IPC_RMID：删除共享内存。标记要销毁的段。实际上，只有在最后一个进程将其分离之后(也就是说，关联结构 shmid_ds 的 shm_nattch 成员为零时)，段才会被销毁。调用者必须是段的所有者或创建者，或具有特权。buf参数被忽略。
 * @param buf 共享内存的状态(属性)
 *        struct shmid_ds {
 *          struct ipc_perm shm_perm;    // 共享内存的权限
 *          size_t shm_segsz;            // 共享内存的大小
 *          time_t shm_atime;            // 最后一次连接共享内存的时间
 *          time_t shm_dtime;            // 最后一次脱离共享内存的时间
 *          time_t shm_ctime;            // 最后一次变更共享内存的时间
 *          pid_t shm_cpid;            // 创建共享内存的进程ID
 *          pid_t shm_lpid;            // 最后一次连接共享内存的进程ID
 *          shmatt_t shm_nattch;        // 当前连接共享内存的进程数
 *        };
 *        struct ipc_perm {
 *          uid_t uid;    // 共享内存的所有者的有效用户ID
 *          gid_t gid;    // 共享内存的所有者的有效组ID
 *          uid_t cuid;    // 共享内存的创建者的有效用户ID
 *          gid_t cgid;    // 共享内存的创建者的有效组ID
 *          mode_t mode;    // 共享内存的访问权限
 *          unsigned short seq;    // 序列号
 *        };
 * @return 成功返回0，失败返回-1
*/
int shmctl(int shmid, int cmd, struct shmid_ds *buf);
```

##### 4.9.2.3 信号量(信号灯集)

信号灯集是实现进程同步的机制，在一个信号灯集中可以有很多个信号灯。在信号灯集内信号灯相互独立，每个灯的值的改变不会影响其他的信号灯，信号灯的值一般设置为二值量(1 或者 0，1 代表有资源，0 代表没有资源)。

```c
/**
 * @brief 创建或者获取信号灯集
 * @param key 用于创建信号灯集的 key，通过 ftok 函数生成
 *        IPC_PRIVATE：只能用于亲缘关系的进程间通信
 * @param nsems 信号灯集中信号灯的个数
 * @param semflg 创建信号灯集的标志
 *        IPC_CREAT：如果不存在则创建，存在则获取
 *        IPC_EXCL：如果不存在则创建，存在则报错
 * @return 成功返回信号灯集的标识符，失败返回 -1
*/
int semget(key_t key, int nsems, int semflg);

/**
 * @brief 控制信号灯集
 * @param semid 信号灯集的标识符
 * @param semnum 信号灯集中信号灯的编号
 * @param cmd 控制命令
 *        IPC_STAT：获取信号灯集的状态
 *        IPC_SET：设置信号灯集的状态
 *        IPC_RMID：第二参数被忽略，第四个参数不用填写
 *        GETVAL：获取信号灯集中信号灯的值(不需要第四个参数)
 *        SETVAL：设置信号灯集中信号灯的值(第四个参数为信号灯的值)
 *        GETPID：获取最后一次执行 semop 操作的进程ID
 *        GETNCNT：获取等待资源的进程数
 *        GETZCNT：获取等待资源的进程数
 * @param arg 信号灯集中信号灯的值
 *        union semun {
 *         int val;    // SETVAL 命令使用的信号灯的值
 *         struct semid_ds *buf;    // IPC_STAT 和 IPC_SET 命令使用的信号灯的状态
 *         unsigned short *array;    // GETALL 和 SETALL 命令使用的信号灯的值
 *         struct seminfo *__buf;    // IPC_INFO 命令使用的信号灯的信息
 *        };
 * @return 失败返回 -1，成功返回 0 或者 GETVAL 信号灯集中信号灯的值
*/
int semctl(int semid, int semnum, int cmd, ...);

/**
 * @brief 对信号灯集中的信号灯进行操作
 * @param semid 信号灯集的标识符
 * @param sops 信号灯集中信号灯的操作
 *        struct sembuf {
 *          unsigned short sem_num;    // 信号灯集中信号灯的编号
 *          short sem_op;    // 信号灯的操作 (1: V 操作，-1: P 操作)
 *          short sem_flg;    // 操作标志 (0: 阻塞操作，IPC_NOWAIT: 非阻塞操作)
 *        };
 * @param nsops 信号灯集中信号灯的个数
 * @return 成功返回 0，失败返回 -1
*/
int semop(int semid, struct sembuf *sops, size_t nsops);
```

#### 4.9.3 BSD 进程间通信方式

BSD: Berkeley Software Distribution 伯克利软件发行版

### 4.10 线程

#### 4.10.1 线程的概念

线程是进程的一个执行流程，是 CPU 调度的基本单位，是比进程更小的能独立运行的基本单位。一个进程可以有多个线程，**多个线程共享进程的资源**。

线程的所有的函数都调用的是第三方库 libpthread.so 中的函数，所以在编译时需要链接该库:
`gcc xxx.c -lpthread -lc`，其中`-lpthread` 表示链接线程库，`-lc` 表示链接 C 标准库(默认的不写也可以)。

安装线程函数的 man 手册:
`sudo apt-get install manpages-posix manpages-posix-dev`

#### 4.10.2 线程 API

多线程执行没有先后顺序，也是采用的抢占式调度，时间片轮询上下文切换，线程的调度是由操作系统完成的，程序员无法控制。

```c
/**
 * @brief 创建线程
 * @param thread 线程的标识符
 * @param attr 线程的属性，一般设置为NULL
 * @param start_routine 线程的入口函数
 * @param arg 线程的入口函数的参数
 * @return 成功返回0，失败返回错误码
*/
int pthread_create(pthread_t *thread, const pthread_attr_t *attr, void *(*start_routine) (void *), void *arg);

pthread_t pthread_self(void);  /* 获取线程自身的线程标识符(线程号) */

/**
 * @brief 线程退出
 * @param retval 线程的返回值
*/
void pthread_exit(void *retval);

/**
 * @brief 线程等待
 * @param thread 等待的线程标识符
 * @param retval 线程的返回值
 * @return 成功返回0，失败返回错误码
*/
int pthread_join(pthread_t thread, void **retval);

/*多线程有两种状态：结合态(joinable) 和 分离态(detached)，joinable 状态的线程需要调用 pthread_join() 函数进行等待回收，否则会产生僵尸线程，detached 状态的线程不需要调用 pthread_join() 函数进行等待，线程结束后会被自动回收。*/
/**
 * @brief 线程分离
 * @param thread 线程标识符
 * @return 成功返回0，失败返回错误码
*/
int pthread_detach(pthread_t thread);
// pthread_detach 函数可以用在主线程中分离子线程，也可以用在子线程中分离自己。

/*线程的取消是指终止线程的执行，线程的取消有两种类型：同步取消和异步取消。同步取消是指线程主动检查是否需要取消，异步取消是指线程被动接收取消信号。*/
/**
 * @brief 线程取消
 * @param thread 线程标识符
 * @return 成功返回0，失败返回错误码
*/
int pthread_cancel(pthread_t thread);

/**
 * @brief 设置线程是否可被取消
 * @param state 线程的取消状态
 *        PTHREAD_CANCEL_ENABLE：允许取消(默认) 1
 *        PTHREAD_CANCEL_DISABLE：不允许取消 0
 * @param oldstate 旧的线程的取消状态
 * @return 成功返回0，失败返回错误码
*/
int pthread_setcancelstate(int state, int *oldstate);

/**
 * @brief 设置线程的取消类型
 * @param type 线程的取消类型
 *        PTHREAD_CANCEL_DEFERRED：延迟取消(线程检查取消点后取消) 0
 *        PTHREAD_CANCEL_ASYNCHRONOUS：异步取消(默认，立即取消) 1
 * @param oldtype 旧的线程的取消类型
 * @return 成功返回0，失败返回错误码
*/
int pthread_setcanceltype(int type, int *oldtype);
```

### 4.11 多线程同步互斥

线程的同步互斥是指多个线程访问共享资源时，为了保证数据的一致性，需要对共享资源进行互斥访问。

互斥：**同一时刻只允许一个线程访问共享资源**，不能保证哪个线程争抢到资源，但是最终只能有一个线程获取到资源。
同步：**线程之间按照一定的顺序访问共享资源**，不会出现竞争，不会有同时访问的情况。同步一般用在**生产者消费者模型**上。

#### 4.11.1 互斥

互斥锁：**pthread_mutex_t**，互斥锁是一种**二值信号量**，用于保护共享资源，同一时刻只允许一个线程访问共享资源，其他线程需要等待。

```c
pthread_mutex_t mutex;  /* 定义互斥锁 */

mutex = PTHREAD_MUTEX_INITIALIZER;  /* 静态初始化线程互斥锁 */

/**
 * @brief 动态初始化互斥锁
 * @param mutex 互斥锁
 * @param attr 互斥锁的属性，一般设置为NULL
 * @return 成功返回0，失败返回错误码
*/
int pthread_mutex_init(pthread_mutex_t *mutex, const pthread_mutexattr_t *attr);

/**
 * @brief 加锁(如果线程获取不到锁的资源，线程阻塞，直到其他的线程将锁释放)
 * @param mutex 互斥锁
 * @return 成功返回0，失败返回错误码
*/
int pthread_mutex_lock(pthread_mutex_t *mutex);
int pthread_mutex_trylock(pthread_mutex_t *mutex);  /* 尝试加锁，如果获取不到锁的资源，立即返回，不会阻塞 */

/**
 * @brief 解锁
 * @param mutex 互斥锁
 * @return 成功返回0，失败返回错误码
*/
int pthread_mutex_unlock(pthread_mutex_t *mutex);

/**
 * @brief 销毁互斥锁
 * @param mutex 互斥锁
 * @return 成功返回0，失败返回错误码
*/
int pthread_mutex_destroy(pthread_mutex_t *mutex);
```

**线程互斥锁死锁问题：**

1. 产生死锁的四个必要条件：
   互斥：一个资源每次只能被一个线程使用。
   请求保持：一个线程因请求资源而阻塞时，对已获得的资源保持不放。
   不可剥夺：线程已获得的资源，在末使用完之前，不能强行剥夺。
   循环等待：若干线程之间形成一种头尾相接的循环等待资源关系。
2. 产生死锁的原因：
   - 系统资源不足。
   - 进程运行推进的顺序不合适。
   - 资源分配不当等。
3. 死锁的预防：
   破坏产生死锁的四个必要条件中的一个或几个。
   - 在全局位置指定锁是否被使用的状态，如果被使用就不再获取(线程获取锁之前，先判断锁的状态)。
   - 尽量避免锁的嵌套使用(一个线程获取了锁，不要再去获取其他的锁)。
   - 给线程上锁指定超时时间(pthread_mutex_timedlock)(如果线程获取不到锁的资源，等待一定的时间，如果还获取不到，就不再等待，直接返回)。
   - 指定线程获取锁的顺序(线程按照一定的顺序获取锁，不会出现循环等待的情况)。

#### 4.11.2 同步

##### 4.11.2.1 无名信号量

无名信号量：**sem_t**，无名信号量是一种**计数信号量**，用于同步线程之间的访问，可以用于线程之间的同步，也可以用于进程之间的同步。

```c
sem_t sem;  /* 定义无名信号量 */

/**
 * @brief 初始化无名信号量
 * @param sem 无名信号量
 * @param pshared 0：线程之间的同步，非0：进程之间的同步(亲缘关系进程)
 * @param value 信号量的初始值
 * @return 成功返回0，失败返回错误码
*/
int sem_init(sem_t *sem, int pshared, unsigned int value);

/**
 * @brief 阻塞等待信号量(如果信号量的值大于0，将信号量的值减1，如果信号量的值等于0，线程阻塞，直到其他的线程将信号量的值加1)
 * @param sem 无名信号量
 * @return 成功返回0，失败返回错误码
*/
int sem_wait(sem_t *sem); /* p(Proberen) 操作 */

/**
 * @brief 尝试等待信号量(如果信号量的值大于0，将信号量的值减1，如果信号量的值等于0，立即返回，不会阻塞)
 * @param sem 无名信号量
 * @return 成功返回0，失败返回错误码
*/
int sem_trywait(sem_t *sem);

/**
 * @brief 释放信号量(将信号量的值加1，如果有线程阻塞，唤醒其中的一个线程)
 * @param sem 无名信号量
 * @return 成功返回0，失败返回错误码
*/
int sem_post(sem_t *sem); /* v(Verhogen) 操作 */

/**
 * @brief 销毁信号量
 * @param sem 无名信号量
 * @return 成功返回0，失败返回错误码
*/
int sem_destroy(sem_t *sem);
```

##### 4.11.2.2 条件变量

条件变量：**pthread_cond_t**，条件变量是一种线程同步的机制，可以用于线程之间的同步，也可以用于进程之间的同步。无名信号量适合使用在线程个数比较少的线程中实现同步。而条件变量适合用在多线程的同步机制，定义一个条件变量即可，不需要像无名信号量一样随着线程数的增多而增多。

```c
pthread_cond_t cond;  /* 定义条件变量 */
pthread_mutex_t mutex;  /* 定义互斥锁 */

/**
 * @brief 初始化条件变量
 * @param cond 条件变量
 * @param attr 条件变量的属性，通常为NULL
 * @return 成功返回0，失败返回错误码
*/
int pthread_cond_init(pthread_cond_t *cond, const pthread_condattr_t *attr);

/**
 * @brief 阻塞等待条件变量(线程阻塞，等待其他线程发送信号)
 * @note 在条件变量中维护了一个队列，这里的互斥锁就是为了解决在往队列中放线程的时候出现竞态问题的。
 * @param cond 条件变量
 * @param mutex 互斥锁
 * @return 成功返回0，失败返回错误码
*/
int pthread_cond_wait(pthread_cond_t *cond, pthread_mutex_t *mutex);

/**
 * @brief 唤醒等待条件变量的线程(唤醒等待条件变量的线程中的一个线程)
 * @param cond 条件变量
 * @return 成功返回0，失败返回错误码
*/
int pthread_cond_signal(pthread_cond_t *cond);

/**
 * @brief 唤醒等待条件变量的线程(唤醒等待条件变量的线程中的所有线程)
 * @param cond 条件变量
 * @return 成功返回0，失败返回错误码
*/
int pthread_cond_broadcast(pthread_cond_t *cond);

/**
 * @brief 销毁条件变量
 * @param cond 条件变量
 * @return 成功返回0，失败返回错误码
*/
int pthread_cond_destroy(pthread_cond_t *cond);
```

### 4.12 线程池

## 5. 网络编程

### 5.1 网络编程基础

socket 通信：socket 是一种通信机制，是一种通信的抽象概念，是对 TCP/IP 协议的封装，是一种编程接口。可以理解为一种文件，可以通过文件描述符进行操作。可以通过 socket 进行通信的两个进程可以在同一台主机上，也可以在不同的主机上。

socket 通信的过程：

- 服务端：创建 socket -> 绑定地址 -> 监听 -> 接收连接 -> 通信 -> 关闭
- 客户端：创建 socket -> 连接 -> 通信 -> 关闭

### 5.2 网络发展的历史

- ARPANET：美国国防部高级研究计划局，1969 年建立的一个分组交换网，是互联网的前身。即阿帕网，使用网络控制协议 NCP。
  NCP: Network Control Protocol，是一种早期的网络协议，是 TCP/IP 协议的前身。不能互联不同类型的计算机和不同类型的操作系统，没有纠错功能，不能保证数据的可靠性。
- TCP/IP：传输控制协议/因特网互联协议，是一组用于实现主机间连接的通信协议，是互联网的基础。
  TCP: Transmission Control Protocol，用来保证数据传输的可靠性。
  IP: Internet Protocol，负责数据包的发送和路由选择。
- 网络体系结构：**OSI 七层模型，TCP/IP 四层模型。**
  OSI 七层模型：应用层、表示层、会话层、传输层、网络层、数据链路层、物理层。**(物链网传会表应)**
  TCP/IP 四层模型：应用层、传输层、网络层、数据链路层。

内层常见的网络协议：

|     层     | 协议  |                                                   功能                                                   |  端口号  |
| :--------: | :---: | :------------------------------------------------------------------------------------------------------: | :------: |
|   应用层   | HTTP  |                  超文本传输协议(Hypertext Transfer Protocol)<br>万维网的数据通信的基础                   |  **80**  |
|            | HTTPS |        安全超文本传输协议(Hypertext Transfer Protocol Secure)<br>HTTP 的安全版，使用 SSL/TLS 加密        |   443    |
|            |  FTP  |      文件传输协议(File Transfer Protocol)<br>用于在网络上进行文件传输的一套标准协议，使用 TCP 传输       |  **21**  |
|            | TFTP  |       简单文件传输协议(Trivial File Transfer Protocol)<br>是一个简单的文件传输协议，使用 UDP 传输        |  **69**  |
|            | SMTP  |                  简单邮件传输协议(Simple Mail Transfer Protocol)<br>用于发送和接收邮件                   |    25    |
|            |  NFS  |     网络文件系统(Network File System)<br>允许网络中的计算机之间通过 TCP/IP 网络共享资源(文件和目录)      | **2049** |
|            |  DNS  |    域名系统(Domain Name System)<br>用于将域名和 IP 地址相互映射的分布式数据库，是互联网的一项核心服务    |    53    |
|            |  SSH  |                   安全外壳协议(Secure Shell)<br>用于计算机之间的加密登录，替代 Telnet                    |  **22**  |
|   传输层   |  TCP  |              传输控制协议(Transmission Control Protocol)<br>提供可靠的、面向连接的通信服务               |    21    |
|            |  UDP  |             用户数据报协议(User Datagram Protocol)<br>提供无连接的、不可靠的、快速的通信服务             |    20    |
|   网络层   |  IP   |    网际协议(Internet Protocol)<br>负责数据包的发送和路由选择，能够在多个不同网络间实现信息传输的协议     |    无    |
|            | ICMP  | Internet 控制报文协议(Internet Control Message Protocol)<br>用于在 IP 主机、路由器之间传递控制消息(**ping**) |    无    |
|            | IGMP  | Internet 组管理协议(Internet Group Management Protocol)<br>用于在 IP 主机、路由器之间传递组成员关系信息  |    无    |
| 数据链路层 |  ARP  |                地址解析协议(Address Resolution Protocol)<br>用于将 IP 地址解析为 MAC 地址                |    无    |
|            | RARP  |          反向地址解析协议(Reverse Address Resolution Protocol)<br>用于将 MAC 地址解析为 IP 地址          |    无    |

每层使用的协议由下层决定。

![每层使用的协议由下层决定](https://pic.imgdb.cn/item/648954901ddac507ccd17b1d.jpg)

数据包的封包和解包：

![数据包的封包和解包](https://pic.imgdb.cn/item/648955251ddac507ccd31801.jpg)

一帧数据指的是数据链路层的数据包，一般包含帧头、数据、帧尾，帧头和帧尾是为了标识数据包的开始和结束，数据链路层的数据包是以太网帧。

![一帧数据](https://pic.imgdb.cn/item/6489569f1ddac507ccd6c0cc.jpg)

大小：帧头 14 字节，帧尾 4 字节，数据最小 46 字节，最大 1500 字节。
其中 1500 叫做最大传输单元，linux 系统中默认使用的是 1500，具体查看可以使用 ifconfig 命令查看 mtu 关键字后面的值。

### 5.3 TCP/UDP

TCP/IP 协议族中的传输层协议有两个：TCP 和 UDP。

区别：

- TCP 是面向连接的，UDP 是无连接的。
- TCP 是可靠的，UDP 是不可靠的。
- TCP 是面向**字节流**的，UDP 是面向**数据报**的。

使用场景：

- TCP 适用于要求可靠传输的场景，如文件传输、邮件传输等。
- UDP 适用于要求实时性的场景，如视频传输、语音传输等。

### 5.4 网络相关的基础知识

#### 5.4.1 字节序

主机字节序：字节在内存中的存储顺序，分为大端字节序和小端字节序。
网络字节序：TCP/IP 协议中规定的一种统一的字节序，即**大端字节序**。

字节序转换的函数：

```c
#include <arpa/inet.h>
uint32_t htonl(uint32_t hostlong); // 将主机字节序转换为网络字节序
uint16_t htons(uint16_t hostshort); // 将主机字节序转换为网络字节序
uint32_t ntohl(uint32_t netlong); // 将网络字节序转换为主机字节序
uint16_t ntohs(uint16_t netshort); // 将网络字节序转换为主机字节序
```

#### 5.4.2 socket

socket 是**应用层和传输层之间**的一个抽象层，它是一组系统调用接口，应用程序可以通过 socket 向网络发送请求或者应答网络请求。

linux 内核的五大功能：

- 进程管理：时间片轮转 上下文切换
- 内存管理：内存的分配和回收
- 文件管理：将一堆 0 1 转换成方便人类识别的字符
- 设备管理：linux 下一切皆文件 硬件设备的驱动管理
- 网络管理：网络协议栈的管理

socket 的类型：

- 流式套接字：SOCK_STREAM，面向连接的套接字，使用 TCP 协议。
- 数据报套接字：SOCK_DGRAM，无连接的套接字，使用 UDP 协议。
- 原始套接字：SOCK_RAW，原始套接字，可以用来发送 ICMP 报文。

#### 5.4.3 网络地址(IP 地址)

MAC 地址: 6 个字节，48 位，前 24 位是厂商编号，后 24 位是厂商分配的编号，用来标识网络设备(网卡)的物理地址，是唯一的。

MAC 地址和 IP 地址的关系：MAC 地址是网卡的物理地址，IP 地址是网卡的逻辑地址，一个网卡可以有多个 IP 地址，但是只有一个 MAC 地址。通过 ARP 协议可以将 IP 地址解析为 MAC 地址。

IP 地址：分为网络号和主机号，网络号用来标识网络，主机号用来标识主机。

- IPV4：4 字节，32 位，分为 A 类、B 类、C 类、D 类、E 类。
  | 类型 | 网络号 | 主机号 | 规定最高位 |网络范围 | 使用场景 |
  | :--: | :----: | :----: | :--------: | :-----: | :------: |
  | A | 1 字节 | 3 字节 | 0 | 0-127 | 政府机构 |
  | B | 2 字节 | 2 字节 | 10 | 128-191 | 企业 |
  | C | 3 字节 | 1 字节 | 110 | 192-223 | 小型企业 |
  | D | 无 | 无 | 1110 | 224-239 | 多播(组播) |
  | E | 无 | 无 | 1111 | 240-255 | 保留 |
- IPV6：16 字节，128 位。

其中每个 IP 地址又可以通过路由器，下发局域网 IP 地址，局域网 IP 地址又可以下发给每个主机，这样就形成了一个 IP 地址的层次结构。每类 IP 地址都有专门划分子网的保留段：

![子网的保留段](https://pic.imgdb.cn/item/64896f3a1ddac507cc28abd8.jpg)

子网掩码：用来标识 IP 地址中的网络号和主机号，子网掩码和 IP 地址进行与运算，可以得到网络号。
如：IP 地址：192.168.70.8 子网掩码：255.255.255.0，进行与运算，得到网络号：192.168.70.0。网络号相同的主机可以直接通信(局域网)，网络号不同的主机需要通过路由器转发。这时，该网段内共有 IP 地址 256 个，其中 192.168.70.0 是**网络号**，是不能占用的；192.168.70.255 是**广播地址**，也不能占用；**网关设备**也需要占用一个 IP 地址，一般是同一局域网内可用的最小编号 192.168.70.1。
所以能容纳的主机数：256-1-1(网关设备也可以算作一台 IP 主机) = 254

子网掩码不一定都是 255.255.255.0，网关设备的 IP 地址也不一定是编号最小的。

DNS：Domain Name System，域名系统，用于将域名解析为 IP 地址。

点分十进制字符串和网络字节序的转换：

```c
#include <arpa/inet.h>
in_addr_t inet_addr(const char *cp); // 点分十进制字符串转换为网络字节序
char *inet_ntoa(struct in_addr in); // 网络字节序转换为点分十进制字符串
```

#### 5.4.4 端口号

端口号：用来标识一个应用程序，范围是 0-65535，其中 0-1023 是保留端口，一般用于系统服务，1024-65535 是可用端口，一般用于用户程序。

端口号和 IP 地址的组合可以唯一标识一个网络应用程序。

协议与服务的关系：

- 协议是控制对等实体之间通信的规则，是水平的。
  服务是下层通过层间接口向上层提供的功能，是垂直的。
- 协议的实现保证了能够向上一层提供服务，要实现本层协议还需使用下层提供的 服务。

协议通过服务来实现，服务就是程序，就有对应的端口号。

### 5.5 网络编程

#### 5.5.1 TCP 网络编程

TCP 服务端编程：

```c
#include <sys/socket.h>

/**
 * @brief 创建套接字
 * @param domain 协议域，AF_INET(IPv4)、AF_INET6(IPv6)、AF_LOCAL(本地通信)、AF_ROUTE(路由套接字)、AF_KEY(秘钥套接字)
 * @param type 套接字类型，SOCK_STREAM(字节流套接字)、SOCK_DGRAM(数据报套接字)、SOCK_SEQPACKET(有序分组套接字)、SOCK_RAW(原始套接字)
 * @param protocol 指定协议，一般为 0
 * @return int 成功返回套接字描述符，失败返回 -1
*/
int socket(int domain, int type, int protocol);

// 填充地址结构体
struct sockaddr_in {
    sa_family_t sin_family; // 地址族
    uint16_t sin_port; // 端口号
    struct in_addr sin_addr; // IPv4 地址
    char sin_zero[8]; // 无意义，填充 0
};
struct in_addr {
    in_addr_t s_addr; // IPv4 地址
};

/**
 * @brief 绑定套接字
 * @param sockfd 套接字描述符
 * @param addr 指向要绑定的地址结构体
 * @param addrlen 地址结构体长度
 * @return int 成功返回 0，失败返回 -1
*/
int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen);

/**
 * @brief 监听套接字
 * @param sockfd 套接字描述符
 * @param backlog 最大连接数
 * @return int 成功返回 0，失败返回 -1
*/
int listen(int sockfd, int backlog);

/**
 * @brief 接受连接
 * @param sockfd 套接字描述符
 * @param addr 指向连接成功的客户端地址结构体
 * @param addrlen 地址结构体长度
 * @return int 成功返回新的套接字描述符，失败返回 -1
*/
int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen);

/**
 * @brief 发送数据
 * @param sockfd 套接字描述符
 * @param buf 发送缓冲区
 * @param len 发送数据长度
 * @param flags 指定发送方式，0-默认，MSG_DONTROUTE-不查找路由表直接发送
 * @return int 成功返回发送的字节数，失败返回 -1
*/
ssize_t send(int sockfd, const void *buf, size_t len, int flags);

/**
 * @brief 接收数据
 * @param sockfd 套接字描述符
 * @param buf 接收缓冲区
 * @param len 接收数据长度
 * @param flags 指定接收方式，0-默认，MSG_DONTWAIT-非阻塞，MSG_OOB-接收带外数据
 * @return int 成功返回接收的字节数，失败返回 -1
*/
ssize_t recv(int sockfd, void *buf, size_t len, int flags);

/**
 * @brief 关闭套接字
 * @param sockfd 套接字描述符
 * @return int 成功返回 0，失败返回 -1
*/
int close(int sockfd);
```

TCP 客户端编程：

```c
#include <sys/socket.h>

int socket(int domain, int type, int protocol);

/**
 * @brief 连接服务器
 * @param sockfd 套接字描述符
 * @param addr 指向要连接的服务器地址结构体
 * @param addrlen 地址结构体长度
 * @return int 成功返回 0，失败返回 -1
*/
int connect(int sockfd, const struct sockaddr *addr, socklen_t addrlen);

ssize_t send(int sockfd, const void *buf, size_t len, int flags);
ssize_t recv(int sockfd, void *buf, size_t len, int flags);
int close(int sockfd);
```

> TCP 粘包问题：
>
> 原因：
>
> 1. Nagle 算法：将多个小的包组装成整体发送
> 2. 缓冲区问题
>
> 解决办法：
>
> 1. 规定一次发送的大小，协议(“len|text”)，收的使用写入 len 大小的数据
> 2. 每次计算大小
> 3. 加分隔符确定数据边界，如 strlen 的边界‘\0’

> 休眠：不占用 cpu(sleep)
>
> 延时：占用 cpu(delay)

#### 5.5.2 UDP 网络编程

UDP 服务端编程：

```c
#include <sys/socket.h>

int socket(int domain, int type, int protocol); // 创建数据包套接字
int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen); // 绑定套接字

/**
 * @brief 发送数据
 * @param sockfd 套接字描述符
 * @param buf 发送缓冲区
 * @param len 发送数据长度
 * @param flags 指定发送方式，0-默认，MSG_DONTROUTE-不查找路由表直接发送
 * @param dest_addr 指向目标地址结构体
 * @param addrlen 目标地址结构体长度
 * @return int 成功返回发送的字节数，失败返回 -1
*/
ssize_t sendto(int sockfd, const void *buf, size_t len, int flags, const struct sockaddr *dest_addr, socklen_t addrlen);

/**
 * @brief 接收数据
 * @param sockfd 套接字描述符
 * @param buf 接收缓冲区
 * @param len 接收数据长度
 * @param flags 指定接收方式，0-默认，MSG_DONTWAIT-非阻塞，MSG_OOB-接收带外数据
 * @param src_addr 指向发送端地址结构体
 * @param addrlen 发送端地址结构体长度
 * @return int 成功返回接收的字节数，失败返回 -1
*/
ssize_t recvfrom(int sockfd, void *buf, size_t len, int flags, struct sockaddr *src_addr, socklen_t *addrlen);
int close(int sockfd);
```

UDP 客户端编程：

```c
#include <sys/socket.h>

int socket(int domain, int type, int protocol); // 创建数据包套接字
ssize_t sendto(int sockfd, const void *buf, size_t len, int flags, const struct sockaddr *dest_addr, socklen_t addrlen);
ssize_t recvfrom(int sockfd, void *buf, size_t len, int flags, struct sockaddr *src_addr, socklen_t *addrlen);
int close(int sockfd);
```

#### 5.5.3 wireshark 抓包

软件说明:

> Wireshark 是网络包分析工具。
>
> 网络包分析工具的主要作用是尝试捕获网络包，并尝试显示包的尽可能详细的情况。
> ​ 网络管理员用来解决网络问题
> ​ 网络安全工程师用来检测安全隐患
> ​ 开发人员用来测试协议执行情况
> ​ 初学者可以用来学习网络协议

> 过滤器的使用：
> 常见的过滤方式：
> tcp.port\==8888
> ip.dst\==xxxxx
> ip.src\==xxxxx
> ip.addr==xxxx
> 过滤的语句可以使用 and 或者 or 连接多句

抓包:

- 链路层

  > 以太网头(MAC 头)**14 字节**：目的地址 6，源地址 6，网络层使用协议类型 2
  >
  > 0x0800 IP 协议 IPV4
  > 0x0806 ARP 协议
  > 0x8035 RARP 协议
  >
  > **注意：交换机是工作在链路层的设备，是根据目的 mac 地址决定如何转发消息的。局域网内部根据 MAC 地址转发，跨网段根据 IP 地址转发。**

- 网络层

  > IP 报头 **20 字节**：版本 首部长度(5->20) 总长度 TTL(跳数限制) 后面的协议 源 IP 目的 IP
  >
  > **注意：路由器是工作在网络层的设备，他是根据目的 ip 地址来决定如何转发数据的。**

- 传输层

  > TCP 报头 **20 字节**：源端口号 目的端口号 序列号 Seq 确认号 Ack 首部长度(5->20) 窗口尺寸
  >
  > 端口号标志进程
  >
  > **连接机制：**
  >
  > **Seq(Sequence Number)序列号 Ack(Sequence Number)确认号 32bin** 校验机制
  >
  > SYN FIN ACK **标志位** **1bin**
  >
  > SYN(synchronous) Seq
  >
  > FIN(finish) Seq
  >
  > ACK(acknowledgement character) 应答数据包 Ack
  >
  > `重传机制保证数据无误`
  >
  > `滑动窗口机制(65535)提高效率`
  >
  > 标志位：每个标志位占用 1Bit，共有 6 个，分别为 URG、ACK、PSH、RST、SYN、FIN，具体含义如下：
  >
  > - URG：紧急指针（urgent pointer）有效。
  > - ACK：确认序号有效。
  > - PSH：接收方应该尽快将这个报文交给应用层。
  > - RST：重置连接。
  > - SYN：建立一个新连接。
  > - FIN：断开一个连接。

  **TCP 的三次握手四次挥手：**

  > TCP 三次握手四次挥手：
  > 三次握手发生在建立连接的过程中，由**客户端**发起，通信双方确认对方收发数据能力没问题,**也是同步序列号的过程**。(至少三次，四次没必要)
  >
  > 发生在**客户端 connect()和服务器 accept()\[listen()\]**之间
  >
  > 四次挥手发生在断开连接的过程中，由**主动关闭方**发起(一般情况下都由客户端发起的)。

```shell
SYN Seq=x;
SYN Seq=y, ACK Ack=x+1 ;
ACK Ack=y+1;

FIN Seq=x;
ACK Ack=x+1;
FIN Seq=y;
ACK Ack=y+1;
```

- 应用层

  > (send)以 16 进制显示用户数据

#### 5.5.4 TCP/UDP 网络编程总结

TCP 网络编程:

![TCP 网络编程](https://pic.imgdb.cn/item/6489a1491ddac507ccc01819.jpg)

1. 客户端一般不需要绑定自己的网络信息结构体？
   因为操作系统会自动给客户端的 ip 地址和端口号赋值，也方便用户操作。如果想要手动指定，也可以，需要调用 bind()函数即可。
2. 服务器端 accept 函数的后两个参数即使设置成 NULL，服务器也可以给客户端回复消息？
   原因是，服务器侧不是依赖于手动给定的 IP 地址和端口号来联系客户端的，而是给每个客户端都分配一个独立的文件描述符 acceptfd，来专门用于和该客户端通信，也就是说 TCP 的服务器，**acceptfd 和客户端是一一对应的关系**。**(connect()将客户端的网络信息结构体发送给服务端 accept())**
3. TCP 网络编程中可以使用 read/write recv/send recvfrom/sendto 来收发数据。
4. 服务器端的 accept 函数本质就是一个阻塞的读函数，也就是一个接收函数，客户端的 connect 函数本质就是个写函数，也就是一个发送函数，收发的数据本质就是客户端的网络信息结构体。
5. **TCP 的服务器默认的是一个循环服务器，没法同时处理多个客户端的请求**?
   原因是 tcp 的服务器有两个阻塞函数 accept 和 recv，两个函数之间相互会有影响。
   可以使用 多进程 多线程 IO 多路复用 来解决。

UDP 网络编程:

![UDP 网络编程](https://pic.imgdb.cn/item/6489a2721ddac507ccc22d9b.jpg)

1. UDP 是无连接的，但是也可以双向的收发数据?
   因为 UDP 使用的是 recvfrom/sendto 来收发数据，sendto 时可以指定接收方的信息。
   sendto 函数相当于 send 函数和 connect 函数的二合一
   recvfrom 函数相当于 recv 函数和 accept 函数的二合一
2. UDP 中客户端也可以使用 connect 函数先将自己的网络信息结构体发给服务器，然后就可以使用 send 和 recv 收发数据了。
3. 如果 UDP 服务器端的 recvfrom 函数的后两个参数设置成 NULL 了，这样接收数据是没有问题的，但是就没法给发送方回信了，因为 sendto 的后两个参数没没法填写，没有接收客户端的网络信息结构体。
4. **UDP 服务器默认的就是一个并发服务器**？
   因为只有一个阻塞的函数 recvfrom。

### 5.6 IO 模型

> 在 UNIX/Linux 下主要有 4 种 I/O 模型：
>
> 阻塞 I/O：最常用、最简单、效率最低
> 非阻塞 I/O：可防止进程阻塞在 I/O 操作上，需要轮询
> I/O 多路复用：允许同时对多个 I/O 进行控制
> 异步通知(信号驱动 I/O): 一种异步通信模型

1. 阻塞 IO
   当程序执行到**读操作**的时候，如果缓冲区里有内容，则直接读取继续向下执行。如果缓冲区中没有内容，则进程就**会进入休眠态**，直到缓冲区中有内容的时候，内核唤醒该进程，来读取内容，读取后继续向下执行。
2. 非阻塞 IO
   当程序执行到**读操作**的时候，如果缓冲区里有内容，则直接读取继续向下执行。如果缓冲区中没有内容，则进程**不会进入休眠态**，而是直接返回一个错误信息，然后继续向下执行。但是，这种用法需要不停的检查 IO 操作是否准备就绪，十分浪费 CPU 资源。
   有些函数自带非阻塞标志位，但是大部分函数默认是没有非阻塞标志位的，需要使用 `fcntl()` 函数来设置非阻塞。

   ```c
   #include <fcntl.h>
   /**
    * @brief 设置文件描述符的属性
    * @param fd 文件描述符
    * @param cmd 设置的属性
    *         F_GETFL 获取文件描述符的属性 arg被忽略
    *         F_SETFL 设置文件描述符的属性 arg是一个int类型
    *                 其中 O_NONBLOCK 表示非阻塞的标志位
    *         F_SETOWN 设置文件描述符的属主，arg是一个pid(getpid())，表示将信号发送给该进程，用于信号驱动IO
    * @param arg 设置的属性的值
   */
   int fcntl(int fd, int cmd, ... /* arg */ );
   ```

3. IO 多路复用
   **通过一个函数来同时监听多个文件描述符，**当某个文件描述符有数据到达的时候，就会返回该文件描述符，然后程序再去读取该文件描述符的内容。
   有三个函数可以实现 IO 多路复用(默认也是阻塞的)，分别是 `select()` `poll()` `epoll()`，其中 `epoll()` 是 Linux 独有的函数，效率最高。

   ```c
   #include <sys/select.h>
   /**
    * @brief IO 多路复用
    * @param nfds 最大的文件描述符 + 1
    * @param readfds 读文件描述符集合
    * @param writefds 写文件描述符集合
    * @param exceptfds 异常文件描述符集合
    * @param timeout 超时时间
    * @return 成功返回就绪的文件描述符的个数，失败返回 -1
    */
   int select(int nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout);

   /*
   注意事项：
     1.select只能监视小于 FD_SETSIZE(1024) 的文件描述符
     2.select每次返回时会将没有就绪的文件描述符在集合中擦除
        所以在循环中使用select时每次要重置集合
     3.我们一般只关心读文件描述符集合
   */
   void FD_CLR(int fd, fd_set *set); // 将文件描述符在集合中删除
   int  FD_ISSET(int fd, fd_set *set); // 判断文件描述符是否还在集合，不在返回 0，还在	返回 非0
   void FD_SET(int fd, fd_set *set); // 将文件描述符添加到集中
   void FD_ZERO(fd_set *set); // 清空文件描述符集合
   ```

   ```c
   #include <poll.h>

   struct pollfd { // 文件描述符结构体
     int fd; // 文件描述符
     short events; // 监视的事件
     short revents; // 就绪的事件
   };

   /**
    * @brief IO 多路复用
    * @param fds 文件描述符数组
    * @param nfds 文件描述符数组的长度
    * @param timeout 超时时间，单位是毫秒
    * @return 成功返回就绪的文件描述符的个数，失败返回 -1，超时返回 0
   */
   int poll(struct pollfd fds[], nfds_t nfds, int timeout);
   ```

   ```c
   #include <sys/epoll.h>

   struct epoll_event { // 文件描述符结构体
     uint32_t events; // 监视的事件
     epoll_data_t data; // 用户数据
   };

   typedef union epoll_data { // 用户数据，可以是任意类型
     void *ptr;
     int fd;
     uint32_t u32;
     uint64_t u64;
   } epoll_data_t;

   /**
    * @brief 创建一个 epoll 对象
    * @param size epoll 对象中能够保存的最大的文件描述符的个数
    * @return 成功返回一个文件描述符，失败返回 -1
   */
   int epoll_create(int size);

   /**
    * @brief 向 epoll 对象中添加或者修改文件描述符
    * @param epfd epoll 对象的文件描述符
    * @param op 操作类型
    *         EPOLL_CTL_ADD 添加文件描述符
    *         EPOLL_CTL_MOD 修改文件描述符
    *         EPOLL_CTL_DEL 删除文件描述符
    * @param fd 需要添加或者修改的文件描述符
    * @param event 文件描述符的事件
    * @return 成功返回 0，失败返回 -1
   */
   int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event);

   /**
    * @brief 等待文件描述符就绪
    * @param epfd epoll 对象的文件描述符
    * @param events 就绪的文件描述符的数组
    * @param maxevents 数组的长度
    * @param timeout 超时时间
    * @return 成功返回就绪的文件描述符的个数，失败返回 -1
   */
   int epoll_wait(int epfd, struct epoll_event *events, int maxevents, int timeout);
   ```

4. 信号驱动 IO
   信号驱动 IO 是通过信号来通知程序有数据到达，然后程序再去读取数据。

   ```c
   #include <signal.h>

   /**
    * @brief 设置信号的处理方式
    * @param signum 信号
    * @param handler 信号的处理方式
    *         SIG_IGN 忽略信号
    *         SIG_DFL 默认处理方式
    *         函数指针 信号处理函数
    * @return 成功返回 0，失败返回 -1
   */
   void (*signal(int signum, void (*handler)(int)))(int);

   fcntl(fd, F_SETOWN, getpid()); // 设置文件描述符接收信号的进程

   /**
    * @brief 发送信号
    * @param pid 进程的 ID
    * @param sig 信号
    * @return 成功返回 0，失败返回 -1
   */
   int kill(pid_t pid, int sig);
   ```

### 5.7 服务器模型

1. 迭代(循环)服务器模型
   服务器在接收到客户端的连接请求后，就创建一个新的**进程**来处理该客户端的请求，然后继续监听其他客户端的连接请求。
   优点：编程简单，不需要考虑并发问题。
   缺点：每次都要创建新的进程，效率低下。
2. 并发服务器模型
   服务器在接收到客户端的连接请求后，就创建一个新的**线程**来处理该客户端的请求，然后继续监听其他客户端的连接请求。
   优点：效率高，不需要频繁创建进程。
   缺点：编程复杂，需要考虑并发问题。
3. IO 多路复用服务器模型
   **服务器在启动时就创建一个 epoll 对象，然后将监听套接字添加到 epoll 对象中，**当接收到客户端的连接请求后，就将连接套接字添加到 epoll 对象中，然后调用 epoll_wait 等待就绪的套接字，然后处理就绪的套接字。
   优点：编程简单，不需要考虑并发问题。
   缺点：效率低，每次都要遍历所有的套接字。
4. 线程池服务器模型
   **服务器在启动时就创建一定数量的线程，然后将这些线程放入一个线程池中，**当接收到客户端的连接请求后，就将请求放入请求队列中，然后线程池中的线程就会去请求队列中取出请求进行处理。
   优点：效率高，不需要频繁创建线程。
   缺点：编程复杂，需要考虑并发问题。

### 5.8 网络超时检测

## 6. C++基础

## 7. ARM 体系结构与接口技术

### 7.1 名词解释

1. ARM
   - ARM 公司，不生产 CPU，只进行 CPU 的设计，然后授权给其他公司进行生产。
   - ARM 架构，ARM 公司设计的 CPU 的体系结构，包括指令集、寄存器、中断等。
2. ARM 处理器
   ARM 处理器是 ARM 公司设计的 CPU，包括 ARM7、ARM9、ARM11、Cortex-A 系列、Cortex-R 系列、Cortex-M 系列等。A 系列是应用处理器，R 系列是实时处理器，M 系列是微控制器。
3. bootloader
   bootloader 是在操作系统内核运行之前运行的一段程序，**主要功能是初始化硬件设备，然后加载操作系统内核。**(bootloader 是裸机程序)uboot 是一个开源的 bootloader。uboot 是 BootLoader 的一个具象化的表现，uboot 是 BootLoader，但 BootLoader 不仅仅指 uboot，比如 bios 也属于 BootLoader。ARM 架构的 CPU 基本都是使用 uboot，X86 结构的 CPU 基本使用 bios(不开源)。
4. 内核(kernel)
   内核是操作系统的核心，内核的主要功能是管理计算机的硬件资源，为应用程序提供服务。
5. SOC
   SOC(System On Chip)，是指集成了 CPU、控制器单元、存储器、外设接口、时钟等功能的芯片。STM32MP157 是一个 SOC。
6. STM32MP157 系列
   STM32MP157 有 A、C、D、E 四个系列，本人目前使用的型号是 STM32MP157AAA3，该 SOC 的主要特性如下：
   - **双 Cortex-A7 核心，主频 800MHz**
   - **一个 Cortex-M4 核心，主频 209MHz**
7. RISC 和 CISC
   RISC(Reduced Instruction Set Computer)精简指令集计算机，CISC(Complex Instruction Set Computer)复杂指令集计算机。RISC 和 CISC 的区别主要在于指令集的复杂度，RISC 指令集的指令数量少，指令的执行时间短，而 CISC 指令集的指令数量多，指令的执行时间长。RISC 和 CISC 的区别主要体现在 CPU 的设计上，RISC CPU 的设计更加简单，CISC CPU 的设计更加复杂。ARM 处理器是 RISC 架构的 CPU，X86 处理器是 CISC 架构的 CPU。

### 7.2 Cortex-A7 内核工作模式

分成很多不同的工作模式的目的是提高 CPU 的性能和降低功耗。

1. 用户模式(usr mode)
   用户模式是应用程序运行的模式，应用程序只能访问用户空间的内存，不能访问内核空间的内存，是非特权模式也不能进行处理器模式的切换。
2. 系统模式(sys mode)
   系统模式是内核运行的模式，内核可以访问用户空间的内存和内核空间的内存，系统模式与用户模式共用一套寄存器。
3. 中断模式(irq mode)
   低优先级的中断模式，通常用于处理**外部中断**。当处理器处于用户模式或系统模式时，如果发生中断，就会切换到中断模式，然后执行中断处理函数，中断处理函数执行完毕后，就会切换回用户模式或系统模式。
4. 快速中断模式(fiq mode)
   高优先级的中断模式，通常用于处理**内部中断**。有一些专用的寄存器，可以保存中断发生时的现场，从而不需要切换到中断模式，就可以执行中断处理函数。
5. 监控模式(mon mode)
   主要就是用来做安全和非安全模式间的切换的。
6. 未定义指令模式(und mode)
   当处理器执行未定义指令时，就会切换到未定义指令模式。当 CPU 执行到一条不能识别的指令时进入该模式，例如在 ARM 板子上执行 x86 结构的程序就会进入该模式。
7. **系统调用模式(svc mode)**
   系统调用模式是用户模式下的一种特殊模式，用户程序可以通过系统调用指令(swi)进入该模式，然后执行一些特权指令，然后再返回用户模式。在系统复位或者是有软中断触发会进入该模式，**由该模式进行各种处理器模式的切换。**
8. 异常模式(abort mode)
   当处理器执行一条非法指令或者访问非法地址时，就会切换到异常模式。当处理器处于用户模式或系统模式时，如果发生异常，就会切换到异常模式，然后执行异常处理函数，异常处理函数执行完毕后，就会切换回用户模式或系统模式。
9. 虚拟化监控模式(hyp mode)
   该模式是为了支持虚拟化而设计的，一般不会用到。

Cortex-M4 内核只有两种模式，分别是线程模式和异常模式。线程模式运行应用程序，异常模式运行中断处理函数。

### 7.3 Cortex-A7 内核寄存器

Cortex-A7 内核中每个寄存器都是 32 位的，寄存器没有地址，通过寄存器名字来访问寄存器。

1. 通用寄存器
   通用寄存器共有 13 个，分别是 r0-r12，其中 r0-r7 是低位寄存器，r8-r12 是高位寄存器。r0-r3 用于存放函数的参数，r4-r11 用于存放局部变量，r12 用于存放全局变量。
2. r13: 栈指针寄存器(sp)
   该寄存器用于存放栈顶地址，栈顶地址是向下增长的，当栈顶地址为 0 时，表示栈已满。
3. r14: 链接寄存器(lr)
   该寄存器用于存放函数的返回地址，当函数调用时，会将函数的返回地址存放到该寄存器中。
4. r15: 程序计数器(pc)
   该寄存器用于存放下一条指令的地址，当程序执行一条指令时，会将 pc 寄存器的值加 4(因为 ARM 指令长度为 4 字节)，然后再去取指令。
5. cpsr: 当前程序状态寄存器
   该寄存器用于存放程序的状态，主要有以下几个字段：
   - N: 负数标志位，当运算结果为负数时，该位为 1。
   - Z: 零标志位，当运算结果为 0 时，该位为 1。
   - C: 进位标志位，当运算结果产生进位时，该位为 1。
   - V: 溢出标志位，当运算结果产生溢出时，该位为 1。
   - I: 中断屏蔽位，当该位为 1 时，表示屏蔽所有中断。
   - F: 快速中断屏蔽位，当该位为 1 时，表示屏蔽快速中断。
   - T: 指令集位，当该位为 0 时，表示 ARM 指令集，当该位为 1 时，表示 Thumb 指令集。
   - M: 处理器模式位，用于表示当前处于哪种处理器模式，比如 0b10000 表示用户模式，0b10011 表示中断模式，0b10111 表示系统模式。
6. spsr: 保存程序状态寄存器
   该寄存器用于保存 cpsr 寄存器的值，当发生中断或者异常时，会将 cpsr 寄存器的值保存到 spsr 寄存器中。

### 7.4 ARM 内核存储系统

ARM 存储器系统通常由多级构成，分别是内核级、芯片级、板卡级和外设级。

1. 内核级
   内核级它的速度是最快的，通常是指我们**核心内部的寄存器组**，这些寄存器离核心最近，所以速度最快，但是容量相对较低。
2. 芯片级
   芯片级的速度是仅次于内核级的，通常在一般的高性能处理器中都会存在 Cache，此外在有些高级处理器中还会有 TCM(TCM 就是为了弥补 Cache 访问的不确定性，通常用作快速存储器)。
3. 板卡级
   板卡级的速度和芯片级相比也会稍慢一些，但是板卡级的存储会有很大的提升，通常从几 MB 到几 GB 都有。板卡级的存储空间就是为了弥补内核级和芯片级存储容量不够的问题。
4. 外设级
   外设级则是主要用于做数据存储的，其容量基本上都是几百 GB 到几 TB 的空间。主要用来存放用户的各种数据。

### 7.5 指令流水线

指令流水线是一种提高 CPU 性能的技术，它可以让 CPU 同时执行多条指令，从而提高 CPU 的执行效率。指令流水线的原理就是将指令的执行过程分成多个步骤，然后将这些步骤串联起来，这样就可以同时执行多条指令了。

三级流水线：

ARM 指令流水线分为三个阶段，分别是**取指令、译码和执行**。当 CPU 执行一条指令时，会先从内存中取出指令，然后将指令送到译码器中进行译码，译码器会将指令翻译成 CPU 可以识别的指令，然后将指令送到执行器中执行。

五级流水线：

ARM 指令流水线分为五个阶段，分别是**取指令、译码、执行、访存和写回**。当 CPU 执行一条指令时，会先从内存中取出指令，然后将指令送到译码器中进行译码，译码器会将指令翻译成 CPU 可以识别的指令，然后将指令送到执行器中执行，执行器会将指令执行的结果存放到寄存器中，最后将寄存器中的数据写回到内存中。

影响流水线性能的因素：

1. 互锁：当一条指令的执行结果要被另一条指令使用时，就会发生互锁，这时就需要等待上一条指令执行完毕，才能继续执行下一条指令，这样就会降低流水线的效率。
2. 跳转指令：当执行一条跳转指令时，就会发生跳转，这时就需要将流水线中的指令清空，然后重新从跳转地址开始执行，这样也会降低流水线的效率。

### 7.6 ARM 指令集

ARM 指令的格式：`操作码{条件码}{S位}{Rd}{Rn}{操作数}`

- 操作码：要执行的操作，比如 ADD、SUB、MOV 等。
- 条件码：用于指定指令执行的条件，比如 EQ、NE、CS、CC 等。
- S 位：用于指定是否更新 CPSR 寄存器。
- Rd：目标操作数寄存器。
- Rn：源操作数寄存器。
- 操作数：操作数，可以是立即数、寄存器、寄存器偏移量等。

### 7.7 GPIO 简介

**GPIO 是 ARM 处理器中的一种外设**，它可以用来控制外部设备的输入和输出。GPIO 的全称是 General Purpose Input Output，它的作用就是**用来控制外部设备的输入和输出**，比如控制 LED 灯的亮灭、控制蜂鸣器的发声、控制电机的转动等。

### 7.8 串口简介

**串口是一种通信接口(协议)**，它可以用来将数据从一台计算机传输到另一台计算机。串口的全称是 Serial Port，它的作用就是用来将数据从一台计算机传输到另一台计算机，比如将数据从 PC 机传输到单片机，或者将数据从单片机传输到 PC 机。

串行通讯和并行通讯：

- 串行通讯：是在一条线上或者一对差分线上，按照一定的时序将数据一位一位的传输出去。优点是占用管脚少，缺点是速度慢。
- 并行通讯：是在多条线上，同时传输多个数据位。优点是速度快，缺点是占用管脚多。

串口的管脚：

- 3 线制串口：TXD(发送数据)、RXD(接收数据)、GND(地线)
- 5 线制串口：TXD(发送数据)、RXD(接收数据)、RTS(请求发送)、CTS(清除发送)、GND(地线)

串行通讯的数据格式：

一帧数据是指在串行通讯中，从开始发送到发送结束的一段数据，它包含了起始位、数据位、校验位和停止位。

- 起始位：用于标识一帧数据的开始，通常为低电平。1 个 bit。
- 数据位：用于存放数据。5~8 个 bit。
- 校验位：用于校验数据的正确性(可选)。1 个 bit。奇校验(数据传输时高电平的个数是奇数个)、偶校验(数据传输时高电平的个数是偶数个)、无校验(0 位)。
- 停止位：用于标识一帧数据的结束，通常为高电平。1~2 个 bit。

波特率：每秒钟传输的 bit 数，单位是 bps。

流控：用于控制数据的传输，比如当接收端的缓冲区满了时，就可以通过流控来控制发送端停止发送数据。RTS(如果接收端的缓冲区满了，就会将 RTS 置为高电平，发送端就会停止发送数据)、CTS(在发送端发送数据时，如果 CTS 为高电平，就会停止发送数据)。

UART：通用异步收发传输器，它是一种串口通讯协议，它的作用就是用来将数据从一台计算机传输到另一台计算机。

- TTL：逻辑电平，它是一种电平标准，它的作用就是用来标识电平的高低。TTL 多用于近距离的串口通讯。
- RS232：在 TTL 的电平基础上，增加了负电压。
- RS485：在 RS232 的基础上，增加了多机通讯的功能(可以在一条总线上连接多个设备)。

## 8. ARM Linux 驱动开发
