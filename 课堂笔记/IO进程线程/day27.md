## 什么是进程

### 进程的概念

> 进程：**进程是程序的一次执行过程，进程是一个正在执行的任务，进程是分配资源的最小单位。**每一个进程都会分配自己的0-3G的内存空间，0-3G的内存空间有多份，而3-4G内核空间只有一份。在这0-3G内存空间中堆区、栈区、静态区（缓冲区，文件描述符）。进程其实是内核创建的，每个进程在**内核空间**都对应的是一个task_struct的结构体(PCB进程控制块)。正在运行的进程会被放到一个运行队列中，随着**时间片轮询依次来执行进程**。一个进程的崩溃不会影响另外一个进程的执行，**进程的安全性高**。

### 进程和程序的区别

> 程序：**程序是静态的**，没有生命周期的概念，它是有序的指令的集合，在硬盘上存储着
> 进程：进程是程序的一次执行过程，**是动态的**它是有生命周期的，随着程序的执行而运行，随着程序的终止而结束，在内存上存储着。可以分配自己的0-3G的内存空间。
### 进程的组成

> PCB、文本段、数据段

### 进程的种类

> 交互进程：交互进程是由shell维护的，通过shell和用户进行交互，例如文本编辑器就是一个交互进程。
批处理进程：批处理进程的优先级比较低，通常情况下批处理进程都会被放到队列中执行，例如gcc编译程序的过程就是批处理进程。
守护进程：守护进程是一个后台运行的进程，**随着系统**的启动而启动，随着系统的终止而终止，它会脱离终端执行，例如windows上的各种服务。

### PID(process id)进程号

> 在linux系统上进程都会被分配一个ID，这个ID就是进程的标号。在linux系统上所有的进程都可以在/proc目录下查看。在一个系统上可以通过如下命令查看能创建的最大进程的个数：
>
> cat /proc/sys/kernel/pid_max (131072)

### 特殊PID的进程

> 0号进程（idle）:在linux系统启动的时候最先运行的进程就是0号进程，0号进程又叫空闲进程。如果系统上没有其他进程执行那么0号进程就执行。0号进程是1号进程和2号进程的父进程。
1号进程（init）:init进程是由0号进程创建得到的，它的主要工作是系统的初始化。当初始化工作执行完之后，它主要负责回收孤儿进程的资源。
2号进程（kthreadd）:kthreadd是由0号进程创建出来的，它主要负责调度工作（调度器进程）

### 进程相关命令

```shell
# 查看进程的父子关系
ps -ef  
# 查看进程的优先级(PRI)
ps -el
# 一般使用这条命令查看，查看到的进程的信息更完全
ps -ajx  |  grep a.out
PPID    PID   PGID    SID TTY       TPGID STAT   UID   TIME COMMAND
# PPID:父进程号
# PID:进程号
# PGID:进程组ID
# 其中进程组又分为前台进程组和后台进程组，前台进程组只有一个，后台进程组有多个。一个进程组内包含很多个进程，进程具备父子关系。
# SID:会话ID
# 在linux系统上新开一个终端就会默认创建一个会话，一个会话包含多个进程组
# TTY:如果是问号，说明没有终端与之对应
# TPGID:如果是-1就是守护进程

# 可视化查看
top/htop
# 给进程发信号
kill -信号号  PID	
# 查看进程号  
pidof 可执行程序的名字
# 查看最大进程号
cat /proc/sys/kernel/pid_max
# 查看进程作业号
jobs -l
# 切换后台/前台
bg/fg 作业号 
```

### 进程的状态

> 1.进程的状态（7种，可见6种）
>   D  //不可中断的等待态（sleep，不可被信号打断）
>   R  //运行状态
>   S  //可中断的等待态（sleep,可被信号打断）
>   T  //停止状态
>   X  //死亡状态
>   Z  //僵尸态
>   I  //空闲态
>
孤儿进程：一个进程的父进程死亡，此时当前的进程就是孤儿进程，孤儿进程被init收养
僵尸态进程：如果一个进程结束，父进程没有为它收尸，此时当前的进程就是僵尸进程。
>
> 2.进程的附加态（6种）
>   <  //高优先级进程
>   N  //低优先级进程
>   L  //锁在内存上
>   s  //会话组组长
>   l  //包含多线程
>   \+  //前台进程

### 进程优先级

> 实时进程：数值越大优先级越高
> 普通进程：数值越小优先级越高
>
> nice值影响优先级

## 进程的创建

### 创建规则

> 在linux系统中进程的创建是通过拷贝父进程得到的，适当修改里面的内容，例如修改pid和ppid等等。可以通过fork()完成进程的拷贝。

### fork()

```c
pid_t fork(void);
功能：拷贝父进程产生一个子进程
参数：
    @无
返回值：成功父进程收到子进程的pid,子进程收到0.
    	 失败返回-1，置位错误码（子进程没有创建出来）
```

> 按照一定的规则，fork() n次产生2^n^个进程
>
> 如果没有刷新缓冲区，子进程拷贝的时候会将父进程的缓冲区的内容拷贝过来。

### 父子进程执行过程

**父子进程执行没有先后顺序，时间片轮询，上下文切换**

### 父子进程内存空间问题

**变量虚拟地址相同，物理地址不一定相同(没有修改操作相同，有则不同)**