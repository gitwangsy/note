## C++ 

namespace 是C++中的关键字，用来定义一个命名空间

::是一个新符号，称为域解析操作符，在C++中用来指明要使用的命名空间。
站在编译和链接的角度，代码中出现的变量名、函数名、类名等都是一种符号（Symbol）。有的符号可以指代一个内存位置，例如变量名、函数名；有的符号仅仅是一个新的名称，例如 typedef 定义的类型别名。

可以发现，对于不带.h的头文件，所有的符号都位于命名空间 std 中，使用时需要声明命名空间 std；对于带.h的头文件，没有使用任何命名空间，所有符号都位于全局作用域。这也是 C++ 标准所规定的。
C++ 中的输入与输出可以看做是一连串的数据流
cout 和 cin 都是 C++ 的内置对象，而不是关键字。
C++中的对象就像C中变量和函数的标识符，而不是关键字
这种在 C++ 中提前创建好的对象称为内置对象。
endl表示换行，与C语言里的\n作用相同
cout 能够连续地输出。同样 cin 也是支持对多个变量连续输入 默认以空格分隔
取消限制带来的另外一个好处是，可以在 for 循环的控制语句中定义变量
有名称的、可以获取到存储地址的表达式即为左值；反之则是右值。

### const(编译宏)

在C语言中，编译器会先到 m 所在的内存取出一份数据，再将这份数据赋给 n；而在C++中，编译器会直接将 10 赋给 n，没有读取内存的过程，和int n = 10;的效果一样。**C++ 中的常量更类似于#define命令，是一个值替换的过程，只不过#define是在预处理阶段替换，而常量是在编译阶段替换。**

**C++ 对 const 的处理少了读取内存的过程，优点是提高了程序执行效率，缺点是不能反映内存的变化，一旦 const 变量被修改，C++ 就不能取得最新的值。(volatile)**
**C语言对 const 的处理和普通变量一样，会到内存中读取数据；C++ 对 const 的处理更像是编译时期的#define，是一个值替换的过程。**
普通全局变量的作用域是当前文件，但是在其他文件中也是可见的，使用`extern`声明后就可以使用

C++ 对 const 的特性做了调整，**C++ 规定，全局 const 变量的作用域仍然是当前文件，但是它在其他文件中是不可见的**，这和添加了`static`关键字的全局变量效果类似。
C和C++中全局 const 变量的作用域相同，都是当前文件，不同的是它们的可见范围：C语言中 const 全局变量的可见范围是整个程序，在其他文件中使用 extern 声明后就可以使用；而**C++中 const 全局变量的可见范围仅限于当前文件，在其他文件中不可见**，所以它可以定义在头文件中，多次引入后也不会出错。
**除了成员变量，其他的常量必须在声明的同时初始化。**

> 总结：C++ 中的 const 变量虽然也会占用内存，也能使用`&`获取得它的地址，但是在使用时却更像编译时期的`#define`；也是值替换，可见范围也仅限于当前文件。const修饰符与define宏定义的区别是，const修饰符有数据类型，可以进行**类型检查**，而define宏定义只是字符替换，容易出错。

### new delete

在C++中，这两个函数仍然可以使用，但是C++又新增了两个关键字，new 和 delete：new 用来动态分配内存，delete 用来释放内存。
如果希望分配一组连续的数据，可以使用 new[]

### inline内联函数(编译宏函数)

函数调用是有时间和空间开销的。程序在执行一个函数之前需要做一些准备工作，要将实参、局部变量、返回地址以及若干寄存器都压入栈中，然后才能执行函数体中的代码；函数体中的代码执行完毕后还要清理现场，将之前压入栈中的数据都出栈，才能接着执行函数调用位置以后的代码。
如果函数体代码比较多，需要较长的执行时间，那么函数调用机制占用的时间可以忽略；如果函数只有一两条语句，那么大部分的时间都会花费在函数调用机制上，这种时间开销就就不容忽视。
为了消除函数调用的时空开销，C++ 提供一种提高效率的方法，即在编译时将函数调用处用函数体替换，类似于C语言中的宏展开。这种在函数调用处直接嵌入函数体的函数称为内联函数（Inline Function），又称内嵌函数或者内置函数。
注意，要在函数定义处添加 inline 关键字，在函数声明处添加 inline 关键字虽然没有错，但这种做法是无效的，编译器会忽略函数声明处的 inline 关键字。inline 是一种“用于实现的关键字”，而不是一种“用于声明的关键字”
所以我们一般是将非常短小的函数声明为内联函数。
使用内联函数的缺点也是非常明显的，编译后的程序会存在多份相同的函数拷贝，如果被声明为内联函数的函数体非常大，那么编译后的程序体积也将会变得很大，所以再次强调，一般只将那些短小的、频繁调用的函数声明为内联函数。
最后需要说明的是，对函数作 inline 声明只是程序员对编译器提出的一个建议，而不是强制性的，并非一经指定为 inline 编译器就必须这样做。编译器有自己的判断能力，它会根据具体情况决定是否这样做。
所以在编写C++代码时我推荐使用内联函数来替换带参数的宏。可以定义在头文件中。
内联函数在编译时会将函数调用处用函数体替换，编译完成后函数就不存在了，所以在链接时不会引发重复定义错误。这一点和宏很像，宏在预处理时被展开，编译时就不存在了。从这个角度讲，**内联函数更像是编译期间的宏**。
内联函数虽然叫做函数，在定义和声明的语法上也和普通函数一样，但它已经失去了函数的本质。函数是一段可以重复使用的代码，它位于虚拟地址空间中的代码区，也占用可执行文件的体积，而内联函数的代码在编译后就被消除了，不存在于虚拟地址空间中，没法重复使用。

> 总结：综合本节和上节的内容，可以看到内联函数主要有两个作用，一是消除函数调用时的开销，二是取代带参数的宏。不过我更倾向于后者，取代带参数的宏更能凸显内联函数存在的意义。

### 默认参数

所谓默认参数，指的是当函数调用中省略了实参时自动使用的一个值，这个值就是给形参指定的默认值。
C++规定，默认参数只能放在形参列表的最后，而且一旦为某个形参指定了默认值，那么它后面的所有形参都必须有默认值。实参和形参的传值是从左到右依次匹配的，默认参数的连续性是保证正确传参的前提。
默认参数并非编程方面的重大突破，而只是提供了一种便捷的方式。在以后设计类时你将发现，通过使用默认参数，可以减少要定义的析构函数、方法以及方法重载的数量。
C/C++语言有四种作用域，分别是函数原型作用域、局部作用域（函数作用域）、块作用域、文件作用域（全局作用域）。

> 总结：C++规定，在给定的作用域中只能指定一次默认参数。在给定的作用域中一个形参只能被赋予一次默认参数。

### 重载(二义性和类型转换)

C++允许多个函数拥有相同的名字，只要它们的参数列表不同就可以，这就是函数的重载（Function Overloading）。借助重载，一个函数名可以有多种用途。重载就是在一个作用范围内（同一个类、同一个命名空间等）有多个名称相同但参数不同的函数。
参数列表又叫参数签名，包括参数的类型、参数的个数和参数的顺序，只要有一个不同就叫做参数列表不同。函数返回值也不能作为重载的依据。
C++代码在编译时会根据参数列表对函数进行重命名。当发生函数调用时，编译器会根据传入的实参去逐个匹配，以选择对应的函数，如果匹配失败，编译器就会报错，这叫做重载决议（Overload Resolution）。**从这个角度讲，函数重载仅仅是语法层面的，本质上它们还是不同的函数，占用不同的内存，入口地址也不一样。**在进行重载决议时编译器按照优先级顺序来处理实参的类型，C++ 标准还规定，编译器应该按照从高到低的顺序来搜索重载函数，首先是精确匹配，然后是类型提升，最后才是类型转换；一旦在某个优先级中找到唯一的一个重载函数就匹配成功，不再继续往下搜索。**注意，类型提升和类型转换不是一码事！类型提升是积极的，是为了更加高效地利用计算机硬件，不会导致数据丢失或精度降低；而类型转换是不得已而为之，不能保证数据的正确性，也不能保证应有的精度。类型提升只有上表中列出的几种情况，其他情况都是类型转换。**

### C/C++混合编程

C++ 和 C 可以进行混合编程。但需要注意的是，由于 C++ 和 C 在程序的编译、链接等方面都存在一定的差异，而这些差异往往会导致程序运行失败。 C++ 会在程序的编译阶段对函数的函数名进行“再次重命名”，C不会，使用 C 和 C++ 进行混合编程时，考虑到对函数名的处理方式不同，势必会造成编译器在程序链接阶段无法找到函数具体的实现，导致链接失败。，C++ 给出了相应的解决方案，即借助 extern "C"，就可以轻松解决 C++ 和 C 在处理代码方式上的差异性。**对于 extern "C"，读者大可以将其看做一个整体，和 extern 毫无关系。它的功能是让编译器以处理 C 语言代码的方式来处理修饰的 C++ 代码。**
```c++
//头文件中如此编写
#ifdef __cplusplus
extern "C"{
#endif

void display();
    
#ifdef __cplusplus
}
#endif
```

### 类和对象

类只是一个模板（Template），编译后不占用内存空间，所以在定义类时不能对成员变量进行初始化，因为没有地方存储数据。只有在创建对象以后才会给成员变量分配内存，这个时候就可以赋值了。
除了创建单个对象，还可以创建对象数组
动态分配内存是指在堆区分配
在栈上创建出来的对象都有一个名字，比如 stu，使用指针指向它不是必须的。但是通过 new 创建出来的对象就不一样了，它在堆上分配内存，没有名字，只能得到一个指向它的指针，所以必须使用一个指针变量来接收这个指针，否则以后再也无法找到这个对象了，更没有办法使用它。也就是说，使用 new 在堆上创建出来的对象是匿名的，没法直接使用，必须要用一个指针指向它，再借助指针来访问它的成员变量或成员函数。
`::`被称为域解析符（也称作用域运算符或作用域限定符）

在类体中和类体外定义成员函数是有区别的：**在类体中定义的成员函数会自动成为内联函数**，在类体外定义的不会。当然，在类体内部定义的函数也可以加 inline 关键字，但这是多余的，因为类体内部定义的函数默认就是内联函数。

内联函数一般不是我们所期望的，它会将函数调用处用函数体替代，所以我建议在类体内部对成员函数作声明，而在类体外部进行定义，这是一种良好的编程习惯，实际开发中大家也是这样做的。

当然，如果你的函数比较短小，希望定义为内联函数，那也没有什么不妥的。

如果你既希望将函数定义在类体外部，又希望它是内联函数，那么可以在定义函数时加 inline 关键字。当然你也可以在函数声明处加 inline，不过这样做没有效果，编译器会忽略函数声明处的 inline，我们已在《如何规范地使用C++内联函数》中对这点进行了详细讲解。

### 类成员的访问权限及封装

Java、C# 程序员注意，C++ 中的 public、private、protected 只能修饰类的成员，不能修饰类，C++中的类没有共有私有之分。**被称为成员访问限定符。所谓访问权限，就是你能不能使用该类中的成员。**
类的声明和成员函数的定义都是类定义的一部分，在实际开发中，我们通常将类的声明放在头文件中，而将成员函数的定义放在源文件中。
成员变量大都以`m_`开头，这是约定成俗的写法，不是语法规定的内容。以`m_`开头既可以一眼看出这是成员变量，又可以和成员函数中的形参名字区分开。
**所谓封装，是指尽量隐藏类的内部实现，只向用户提供有用的成员函数。**

声明为 private 的成员和声明为 public 的成员的次序任意，既可以先出现 private 部分，也可以先出现 public 部分。如果既不写 private 也不写 public，**就默认为 private。**
类是创建对象的模板，不占用内存空间，**不存在于编译后的可执行文件中**；而对象是实实在在的数据，需要内存来存储。对象被创建时会在栈区或者堆区分配内存。

### 对象内存模型

**编译器会将成员变量和成员函数分开存储：分别为每个对象的成员变量分配内存，但是所有对象都共享同一段函数代码。**
**成员变量在堆区或栈区分配内存，成员函数在代码区分配内存。对象的大小只受成员变量的影响，和成员函数没有关系。**
如果你希望看到经 Name Mangling 产生的新函数名，可以只声明而不定义函数，这样调用函数时就会产生链接错误，从报错信息中就可以看到新函数名。

### 构造函数

在C++中，有一种特殊的成员函数，它的名字和类名相同，没有返回值，不需要用户显式调用（用户也不能调用），而是在创建对象时自动执行。这种特殊的成员函数就是构造函数（Constructor）。
一个类必须有构造函数，要么用户自己定义，要么编译器自动生成。一旦用户自己定义了构造函数，不管有几个，也不管形参如何，编译器都不再自动生成。
如果用户自己没有定义构造函数，那么编译器会自动生成一个默认的构造函数，只是这个构造函数的函数体是空的，也没有形参，也不执行任何操作。
**最后需要注意的一点是，调用没有参数的构造函数也可以省略括号。**

### 构造函数初始化列表

使用构造函数初始化列表并没有效率上的优势，仅仅是书写方便，尤其是成员变量较多时，这种写法非常简单明了。初始化列表可以用于全部成员变量，也可以只用于部分成员变量。
**注意，成员变量的初始化顺序与初始化列表中列出的变量的顺序无关，它只与成员变量在类中声明的顺序有关。**
构造函数初始化列表还有一个很重要的作用，那就是初始化 const 成员变量。**初始化 const 成员变量的唯一方法就是使用初始化列表。**

### 析构函数

创建对象时系统会自动调用构造函数进行初始化工作，同样，销毁对象时系统也会自动调用一个函数来进行清理工作，例如释放分配的内存、关闭打开的文件等，这个函数就是析构函数（Destructor）。
析构函数（Destructor）也是一种特殊的成员函数，没有返回值，不需要程序员显式调用（程序员也没法显式调用），而是在销毁对象时自动执行。构造函数的名字和类名相同，而析构函数的名字是在类名前面加一个`~`符号。
**注意：析构函数没有参数，不能被重载，因此一个类只能有一个析构函数。如果用户没有定义，编译器会自动生成一个默认的析构函数。**
C++中的 new 和 delete 分别用来分配和释放内存，它们与C语言中 malloc()、free() 最大的一个不同之处在于：**用 new 分配内存时会调用构造函数，用 delete 释放内存时会调用析构函数。**构造函数和析构函数对于类来说是不可或缺的，所以在C++中我们非常鼓励使用 new 和 delete。

### 成员对象和封闭类

一个类的成员变量如果是另一个类的对象，就称之为“成员对象”。包含成员对象的类叫封闭类（enclosed class）。
当封闭类对象消亡时，先执行封闭类的析构函数，然后再执行成员对象的析构函数，成员对象析构函数的执行次序和构造函数的执行次序相反，即先构造的后析构，这是 C++ 处理此类次序问题的一般规律。

### this指针

**this 只能用在类的内部**，this指向的是当前对象，通过 this 可以访问类的所有成员，包括 private、protected、public 属性的。
注意，this 是一个指针，要用`->`来访问成员变量或成员函数。

**this 实际上是成员函数的一个形参**，在调用成员函数时将对象的地址作为实参传递给 this。不过 this 这个形参是隐式的，它并不出现在代码中，而是在编译阶段由编译器默默地将它添加到参数列表中。**它是成员函数和成员变量关联的桥梁。**

### 静态成员变量

在C++中，我们可以使用静态成员变量来实现多个对象共享数据的目标。**静态成员变量是一种特殊的成员变量，它被关键字`static`修饰。**
static 成员变量属于类，**不属于某个具体的对象**，static 成员变量**必须在类声明的外部初始化**。
静态成员变量在初始化时不能再加 static，但必须要有数据类型。被 private、protected、public 修饰的静态成员变量都可以用这种方式初始化。
注意：static 成员变量的内存既不是在声明类时分配，也不是在创建对象时分配，而是**在（类外）初始化时分配。反过来说，没有在类外初始化的 static 成员变量不能使用。**
注意：**static 成员变量不占用对象的内存，而是在所有对象之外开辟内存，即使不创建对象也可以访问。**具体来说，static 成员变量和普通的 static 变量类似，都在内存分区中的全局数据区分配内存。
初始化时可以赋初值，也可以不赋值。如果不赋值，那么会被默认初始化为 0。全局数据区的变量都有默认的初始值 0，而动态数据区（堆区、栈区）变量的默认值是不确定的，一般认为是垃圾值。

### 静态成员函数

静态成员函数与普通成员函数的根本区别在于：**普通成员函数有 this 指针，可以访问类中的任意成员；而静态成员函数没有 this 指针，只能访问静态成员（包括静态成员变量和静态成员函数）。**

### const成员变量(常量)和成员函数(常函数)和对象(常对象)

常成员函数需要在声明和定义的时候在**函数头部的结尾**加上 const 关键字。

如果不希望某些数据被修改，可以使用const关键字加以限定。const 可以用来修饰成员变量和成员函数。
最后再来区分一下 const 的位置：

- 函数开头的 const 用来修饰函数的返回值，表示返回值是 const 类型，也就是不能被修改，例如`const char * getname()`。
- 函数头部的结尾加上 const 表示常成员函数，这种函数只能读取成员变量的值，而不能修改成员变量的值，例如`char * getname() const`。

一旦将对象定义为常对象之后，该对象就只能访问被 const 修饰的成员了（包括 const 成员变量和 const 成员函数），因为非 const 成员可能会修改对象的数据（编译器也会这样假设），C++禁止这样做。

### 友元函数和友元类(firend关键字)

在C++中，一个类中可以有 public、protected、private 三种属性的成员，通过对象可以访问 public 成员，只有本类中的函数可以访问本类的 private 成员。
**借助友元（friend），可以使得其他类中的成员函数以及全局范围内的函数访问当前类的 private 成员。**
友元的关系是单向的而不是双向的。友元的关系不能传递。

### 类也是一种作用域

类中 typedef 定义的类型只能通过类来访问。
在类的外部，类内部成员的名字是不可见的(成员变量名，函数名)。
一旦遇到类名，定义的剩余部分就在类的作用域之内了，这里的剩余部分包括参数列表和函数体(不包括函数返回值)。结果就是，我们可以直接使用类的其他成员而无需再次授权了。

### class和struct的区别

C++中的 struct 和 class 基本是通用的，唯有几个细节不同：

- 使用 class 时，类中的成员默认都是 private 属性的；而使用 struct 时，结构体中的成员默认都是 public 属性的。
- class 继承默认是 private 继承，而 struct 继承默认是 public 继承。
- class 可以使用模板，而 struct 不能。

C++ 没有抛弃C语言中的 struct 关键字 ，其意义就在于给C语言程序开发人员有一个归属感，并**且能让C++编译器兼容以前用C语言开发出来的项目。**

### string

与C风格的字符串不同，string 的结尾没有结束标志`'\0'`。
C++中的string字符串结尾不需要结束标志'\0'，因为**string类会自动在字符串末尾添加一个空字符**。这个空字符不需要手动添加，也**不需要在字符串中占用一个字符位置**。因此，使用string类可以避免一些与'\0'有关的问题，如数组越界和字符串拼接等。
转换函数 c_str()，该函数能够将 string 字符串转换为C风格的字符串，并返回该字符串的 const 指针（const char*）。
字符串拼接：用`+`来拼接字符串时，运算符的两边可以都是 string 字符串，也可以是一个 string 字符串和一个C风格的字符串，还可以是一个 string 字符串和一个字符数组，或者是一个 string 字符串和一个单独的字符。
`insert(),erase(),substr(),find(),rfinf(),find_first_of()`

### 引用

引用(reference)可以看做是数据的一个**别名**，通过这个别名和原来的名字都能够找到这份数据。引用类似于 Windows 中的**快捷方式**，一个可执行程序可以有多个快捷方式，通过这些快捷方式和可执行程序本身都能够运行程序；引用还类似于人的绰号（笔名），使用绰号（笔名）和本名都能表示一个人。
**引用必须在定义的同时初始化**，并且以后也要从一而终，**不能再引用其它数据，这有点类似于常量（const 变量）。** 
引用的本质是一个**指针常量**，引用一旦初始化，就不能再改变了，因此引用必须初始化。
其实引用只是对指针进行了简单的封装，它的底层依然是通过指针实现的，引用占用的内存和指针占用的内存长度一样，在 32 位环境下是 4 个字节，在 64 位环境下是 8 个字节，之所以不能获取引用的地址，是因为编译器进行了内部转换。
如果不希望通过引用来修改原始的数据，那么可以在定义时添加 const 限制，**称为常引用**。
引用作为函数参数时，**传递的是实参的引用**，而不是实参的值，因此在函数内部可以通过引用来修改实参的值。
引用作为函数返回值时，**返回的是引用所指向的数据**，而不是引用本身。在将引用作为函数返回值时应该注意一个小问题，就是不能返回局部数据（例如局部变量、局部对象、局部数组等）的引用，因为当函数调用完成后局部数据就会被销毁，有可能在下次使用时数据就不存在了，C++ 编译器检测到该行为时也会给出警告。
引用和指针的区别：
1. 引用必须在定义的同时初始化，指针可以先定义再初始化。
2. 引用一旦初始化之后就不能再改变了，指针可以修改所指向的地址。

#### 什么样的临时数据会存放到寄存器中？
寄存器离 CPU 近，并且速度比内存快，将临时数据放到寄存器是为了加快程序运行。但是寄存器的数量是非常有限的，容纳不下较大的数据，所以只能将较小的临时数据放在寄存器中。int、double、bool、char 等基本类型的数据往往不超过 8 个字节，用一两个寄存器就能存储，所以这些类型的临时数据通常会放到寄存器中；而对象、结构体变量是自定义类型的数据，大小不可预测，所以这些类型的临时数据通常会放到内存中。
#### 关于常量表达式
常量表达式由于不包含变量，没有不稳定因素，所以在编译阶段就能求值。编译器不会分配单独的内存来存储常量表达式的值，而是**将常量表达式的值和代码合并到一起，放到虚拟地址空间中的代码区。**从汇编的角度看，常量表达式的值就是一个立即数，会被“硬编码”到指令中，不能寻址。所以见下面的代码：
```cpp
int& r = 10; // 错误，常量表达式不能作为引用的初始值
const int& r = 10; // 加了 const 限制就可以了，会创建一个临时变量来存储常量表达式的值
```
**总结起来说，给引用添加 const 限定后，不但可以将引用绑定到临时数据，还可以将引用绑定到类型相近的数据，这使得引用更加灵活和通用，它们背后的机制都是临时变量。**
当引用作为函数参数时，如果在函数体内部不会修改引用所绑定的数据，那么请尽量为该引用添加 const 限制。
**概括起来说，将引用类型的形参添加 const 限制的理由有三个：**

- 使用 const 可以避免无意中修改数据的编程错误；
- 使用 const 能让函数接收 const 和非 const 类型的实参，否则将只能接收非 const 类型的实参；
- 使用 const 引用能够让函数正确生成并使用临时变量。

### 继承与派生

protected 成员和 private 成员类似，也不能通过对象访问。但是当存在继承关系时，protected 和 private 就不一样了：基类中的 protected 成员可以在派生类中使用，而基类中的 private 成员不能在派生类中使用。
**实际上，基类的 private 成员是能够被继承的，并且（成员变量）会占用派生类对象的内存，它只是在派生类中不可见，导致无法使用罢了。**
由于 private 和 protected 继承方式会改变基类成员在派生类中的访问权限，导致继承关系复杂，所以实际开发中我们一般使用 public。
使用 using 关键字可以改变基类成员在派生类中的访问权限，例如将 public 改为 private、将 protected 改为 public。不能改变private成员的访问权限。
如果派生类中的成员（包括成员变量和成员函数）和基类中的成员重名，那么就会遮蔽从基类继承过来的成员。所谓**遮蔽**，就是在派生类中使用该成员（包括在定义派生类时使用，也包括通过派生类对象访问该成员）时，实际上使用的是派生类新增的成员，而不是从基类继承来的。如果希望通过派生类对象访问从基类继承过来的成员，可以使用作用域运算符，例如 `s1.Base::m_x`。基类成员函数和派生类成员函数不构成重载。
#### 构造函数和析构函数
构造函数和析构函数都是成员函数，但是它们的调用时机不同，构造函数在创建对象时调用，析构函数在销毁对象时调用。**构造函数和析构函数都不能被继承**，但是可以被重写。
通过派生类创建对象时必须要调用基类的构造函数，这是语法规定。换句话说，定义派生类构造函数时最好指明基类构造函数；**如果不指明，就调用基类的默认构造函数（或不带参数的构造函数，或有默认参数的构造函数）；如果没有默认构造函数，那么编译失败。**
和构造函数类似，析构函数也不能被继承。与构造函数不同的是，在派生类的析构函数中不用显式地调用基类的析构函数，因为每个类只有一个析构函数，编译器知道如何选择，无需程序员干涉。
析构函数的执行顺序和构造函数的执行顺序也刚好相反，先析构派生类对象，再析构基类对象。
#### 多继承
**基类构造函数的调用顺序和它们在派生类构造函数中出现的顺序无关，而是和声明派生类时基类出现的顺序相同。**派生类的析构函数的调用顺序和构造函数的调用顺序相反，先析构派生类对象，再析构基类对象。
**基类对象的排列顺序和继承时声明的顺序相同。**
