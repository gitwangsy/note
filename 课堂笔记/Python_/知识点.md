# Python

## 基础知识

### Python 是什么

Python 是一种开源免费解释型(脚本语言)、面向对象、动态数据类型的高级程序设计语言。Python 由 Guido van
Rossum 于 1989 年底发明，第一个公开发行版发行于 1991 年。像 Perl 语言一样，Python 源代码同样遵循 GPL(GNU General Public License)协议。

### 编译型和解释型语言

有的编程语言要求必须提前将所有源代码一次性转换成二进制指令，也就是生成一个可执行程序（比如 Windows 下的 .exe
文件），比如 C 语言、C++、Golang、汇编语言等，它们都属于编译型语言，使用的转换工具称为编译器。  
有的编程语言可以一边执行一边转换，需要哪些源代码就转换哪些源代码，不会生成可执行程序，比如 Python、JavaScript、PHP、Shell
等，这类编程语言称为解释型语言，使用的转换工具称为解释器。  
除编译型和解释型语言外，还有一种半编译半解释型语言，比如 Java 和 C#
等，这类语言将源代码先转换成一种中间文件（字节码文件），然后再将中间文件拿到虚拟机中执行。  
编译型语言不能跨平台表现在两个方面：

- 可执行程序不能跨平台
- 源代码不能跨平台

> 由于每次执行程序都需要重新转换源代码，所以解释型语言的执行效率天生就低于编译型语言，甚至是数量级的差距。因此计算机的一些底层功能，或者关键算法，一般都使用
> C/C++ 实现，只有在应用层面（比如网站开发、批处理、小工具等）才会使用解释型语言。  
> 在运行解释型语言的时候，我们始终都需要源代码和解释器，所以说它无法脱离开发环境。  
> 相比于编译型语言，解释型语言几乎都能跨平台，“一次编写，到处运行”是真实存在的，而且比比皆是。

### PEP8

相比于编译型语言，解释型语言几乎都能跨平台，“一次编写，到处运行”是真实存在的，而且比比皆是。

## 变量类型和运算符

### 标识符命名规范

Python 语言中，以下划线开头的标识符有特殊含义，例如:  
以单下划线开头的标识符（如 \_width），表示不能直接访问的类属性，其无法通过 from...import\* 的方式导入；  
**以双下划线开头的标识符（如\_\_add）表示类的私有成员**；  
以双下划线作为开头和结尾的标识符（如 \_\_init\_\_），是专用标识符。因此，除非特定场景需要，应避免使用以下划线开头的标识符。

在 Python 中，标识符的命名应该遵守以下这些规则：  
当标识符用作模块名时，应尽量短小，并且全部使用小写字母，可以使用下划线分割多个字母，例如 game_mian、game_register 等。  
当标识符用作包的名称时，应尽量短小，也全部使用小写字母，不推荐使用下划线，例如 com.mr、com.mr.book 等。  
当标识符用作类名时，应采用单词首字母大写的形式。例如，定义一个图书类，可以命名为 Book。  
模块内部的类名，可以采用 "下划线+首字母大写" 的形式，如 \_Book;  
函数名、类中的属性名和方法名，应全部使用小写字母，多个单词之间可以用下划线分割；  
常量命名应全部使用大写字母，单词之间可以用下划线分割；

### Python 是弱类型的语言

在强类型的编程语言中，定义变量时要指明变量的类型，而且赋值的数据也必须是相同类型的，C 语言、C++、Java 是强类型语言的代表。  
和强类型语言相对应的是弱类型语言，Python、JavaScript、PHP 等脚本语言一般都是弱类型的。  
弱类型语言有两个特点：

- 变量无须声明就可以直接赋值，对一个不存在的变量赋值就相当于定义了一个新变量。
- 变量的数据类型可以随时改变，比如，同一个变量可以一会儿被赋值为整数，一会儿被赋值为字符串。  
  注意，弱类型并不等于没有类型！弱类型是说在书写代码时不用刻意关注类型，但是在编程语言的内部仍然是有类型的。我们可以使用
  type() 内置函数类检测某个变量或者表达式的类型

> Python 的内置函数是指在 Python 解释器中已经定义好的一些函数，可以直接使用，不需要导入任何模块。Python 有很多内置函数，例如 abs()
> 、input()、print()、len()等。

### Python 整型类型(int)

不管对于多大或者多小的整数，Python 只用一种类型存储，就是 int。  
为了提高数字的的可读性，Python 3.x 允许使用下划线\_作为数字（包括整数和小数）的分隔符。通常每隔三个数字添加一个下划线，类似于英文数字中的逗号。下划线不会影响数字本身的值。

### Python 浮点类型(float)

书写小数时必须包含一个小数点，否则会被 Python 当作整数处理。

### Python 复数类型(complex)

复数（Complex）是 Python 的内置类型，直接书写即可。换句话说，Python 语言本身就支持复数，而不依赖于标准库或者第三方库。  
复数由实部（real）和虚部（imag）构成，在 Python 中，复数的虚部以 j 或者 J 作为后缀，具体格式为：`a + bj` 其中 a 表示实部，b 表示虚部。

### Python 字符串类型(str)

Python 字符串中的双引号和单引号没有任何区别。  
**处理字符串中的引号时**：，可以使用转义字符\，也可以使用不同的引号包围字符串  
Python 中的**字符串是不可变**的，也就是说，字符串一旦被创建，就不能被修改。  
**字符串的换行**：Python
不是格式自由的语言，它对程序的换行、缩进都有严格的语法要求。要想换行书写一个比较长的字符串，必须在行尾添加反斜杠\
，Python 也支持表达式的换行，只要在行尾添加反斜杠\ 即可。</br>
**Python 长字符串**：使用三个单引号或者双引号可以对多行内容进行注释，这其实是 Python
长字符串的写法。所谓长字符串，就是可以直接换行（不用加反斜杠\）书写的字符串。如果长字符串没有赋值给任何变量，那么这个长字符串就不会起到任何作用，和一段普通的文本无异，相当于被注释掉了。
注意，此时 Python 解释器并不会忽略长字符串，也会按照语法解析，只是长字符串起不到实际作用而已。

> 转义字符有时候会带来一些麻烦，例如我要表示一个包含 Windows 路径 D:\Program Files\Python 3.8\python.exe 这样的字符串，在
> Python
> 程序中直接这样写肯定是不行的，不管是普通字符串还是长字符串。因为\的特殊性，我们需要对字符串中的每个\都进行转义，也就是写成 D:
> \\\Program Files\\\Python 3.8\\\python.exe 这种形式才行。这种写法需要特别谨慎，稍有疏忽就会出错。为了解决转义字符的问题，Python
> 支持原始字符串。在原始字符串中，\不会被当作转义字符，所有的内容都保持“原汁原味”的样子。**在普通字符串或者长字符串的开头加上 r 前缀，就变成了原始字符串。**
> `str1 = r'原始字符串内容' str2 = r"""原始字符串内容"""`

### Python bytes 类型

bytes 类型是 Python 3.x 新增的类型，它是一种不可变的二进制序列，可以用来存储各种类型的数据，比如图片、视频、音频、文本等。  
bytes 类型的数据是以字节为单位的，每个字节的取值范围是 0~255，也就是说，bytes 类型的数据是由 8 位二进制组成的。  
字节串和字符串类似，也是不可变的，也可以使用索引和切片操作。  
bytes 类型的数据可以使用 encode() 方法转换字符串，也可以使用 decode() 方法转换为字符串。

### Python bool 类型

Python 中的布尔类型只有两个值，True 和 False，分别代表真和假。  
布尔类型可以当做整数来对待，即 True 相当于整数值 1，False 相当于整数值 0。  
在 Python 中，所有的对象都可以进行真假值的测试，包括字符串、元组、列表、字典、对象等。

### Python 缓存重用机制

Python 缓冲机制是为提高程序执行的效率服务的，实际上就是在 Python
解释器启动时从内存空间中开辟出一小部分，用来存储高频使用的数据，这样可以大大减少高频使用的数据创建时申请内存和销毁时撤销内存的开销。  
**id()是内置函数**，该函数的功能是获取变量（对象）所在的内存地址。

### Python input()函数

**input()是内置函数**，函数的作用是从标准输入中读取一行文本，返回值是一个字符串。  
用法为：`str = input([prompt])` prompt 是可选参数，用于指定提示信息，如果不指定，那么就不会有提示信息。

### Python print()函数

print() 函数的详细语法格式如下：  
`print (value,...,sep=' ',end='\n',file=sys.stdout,flush=False)`  
使用 print() 函数输出多个变量时，print() 函数默认以空格隔开多个变量，如果希望改变默认的分隔符，可通过 sep
参数进行设置，例如：`print('hello', 'world', sep=',')`  
在默认情况下，print() 函数输出之后总会换行，这是因为 print() 函数的 end 参数的默认值是“\n”，这个“\n”就代表了换行。如果希望
print() 函数输出之后不会换行，则重设 end 参数即可，例如：`print('hello', end='')`  
file 参数指定 print() 函数的输出目标，file 参数的默认值为 sys.stdout，该默认值代表了系统标准输出，也就是屏幕，因此 print()
函数默认输出到屏幕。实际上，完全可以通过改变该参数让 print()
函数输出到特定文件中，例如：`print('hello', file=open('test.txt', 'w'))`  
print() 函数的 flush 参数用于控制输出缓存，该参数一般保持为 False 即可，这样可以获得较好的性能。  
格式化输出：eg: `print('hello %s' % 'world')`中间的%是一个**分隔符**
，它前面是格式化字符串，后面是要输出的表达式。多个表达式必须使用小括号( )包围起来。  
可以使用格式指定最小输出宽度（至少占用多少个字符的位置），如果输出的内容不足指定的宽度，则在左侧用空格补齐。eg: `print('%10d' % 123)`

### Python 数据类型转换

Python 中的数据类型转换函数有 int()、float()、complex()、str()、bool()、list()、tuple()、dict()、set() 等。  
需要注意的是，在使用类型转换函数时，提供给它的数据必须是有意义的。例如，int() 函数无法将一个非数字字符串转换成整数

### Python 算数运算符

'+'，'-'，'\*'，'/'，'//'，'%'，'\*\*'  
**由于开方是次方的逆运算**，所以也可以使用运算符间接地实现开方运算。例如，要计算 2 的开方，可以使用 2\*\*(1/2)。

### Python 比较运算符

'>'，'>='，'<'，'<='，'=='，'!='，'is'，'is not'  
== 用来比较两个变量的值是否相等，而 is 则用来比对两个变量引用的是否是同一个对象

> 如何判断两个对象是否相同呢？答案是判断两个对象的内存地址。如果内存地址相同，说明两个对象使用的是同一块内存，当然就是同一个对象了；这就像两个名字使用了同一个身体，当然就是同一个人了。

### Python 逻辑运算符

'and'，'or'，'not'  
Python 逻辑运算符可以用来操作任何类型的表达式，不管表达式是不是 bool 类型；同时，逻辑运算的结果也不一定是 bool
类型，它也可以是任意类型。

```python
print(100 and 200)
print(45 and 0)
print("" or "wsyaa.com")
print(18.5 or "wsyaa.com")
```

### Python 三目运算符

Python 中的三目运算符是一种简洁的条件表达式，它可以用来替代简单的 if 语句。  
三目运算符的语法格式如下：`x if 条件表达式 else y`  
三目运算符支持嵌套，即在三目运算符的条件表达式中再使用三目运算符。  
eg：`x if x > y else (y if y > z else z)`

## 序列类型

### Python 序列(Sequence)类型

**序列是指按特定顺序依次排列的一组数据**，它们可以占用一块连续的内存，也可以分散到多块内存中。  
Python 中的序列类型包括字符串(str)、列表(list)、元组(tuple)、字典(dict)、集合(set)等。

> 列表（list）和元组（tuple）比较相似，它们都**按顺序**保存元素，所有的元素占用一块**连续的内存**，每个元素都有自己的**索引**
> ，因此列表和元组的元素都可以通过索引（index）和切片来访问。**它们的区别在于：列表是可以修改的，而元组是不可修改的。**  
> 字典（dict）和集合（set）存储的数据都是**无序**的，每份元素占用**不同的内存**，其中字典元素以 key-value 的形式保存。

#### 序列索引

无论是采用正索引值，还是负索引值，都可以访问序列中的任何元素。负索引值从序列的末尾开始计数，-1 表示最后一个元素，-2
表示倒数第二个元素，以此类推从右向左计数。

#### 序列切片

切片操作是访问序列中元素的另一种方法，它**可以访问一定范围内的元素**
，通过切片操作，可以生成一个新的序列。语法格式如下：`seq[start:end:step]`

> start 表示切片的起始位置，end 表示切片的结束位置，step 表示切片的步长。

#### 序列相加

序列相加是指将两个序列中的元素合并成一个序列，这个操作使用运算符 + 实现。

> 注意：序列相加的两个序列的类型必须相同，否则会引发 TypeError 异常。

#### 序列相乘

序列相乘是指将一个序列中的元素重复多次生成一个新的序列，这个操作使用运算符 \* 实现。

> 注意：序列相乘的两个操作数必须是一个序列，另一个操作数必须是整数，否则会引发 TypeError 异常。

#### 序列成员资格

成员资格是指判断一个元素是否在序列中，这个操作使用运算符 in 实现。和 in 关键字用法相同，但功能恰好相反的，还有 not in
关键字，它用来检查某个元素是否不包含在指定的序列中。

#### 序列相关内置函数

```python
len()  # 函数用来获取序列的长度
max()  # 函数用来获取序列中的最大值
min()  # 函数用来获取序列中的最小值
sum()  # 函数用来计算序列中所有元素的和
str()  # 函数用来将指定的对象转换成字符串
list()  # 函数用来将指定的对象转换成列表
...
sorted()  # 函数用来对序列进行排序，返回一个新的序列
reversed()  # 函数用来对序列进行反转，返回一个新的序列
enumerate()  # 函数用来将一个可遍历的数据对象（如列表、元组或字符串）组合为一个索引序列，同时列出数据和数据下标，一般用在 for 循环当中
```

### 列表(list)[]

列表是 Python 中最常用的数据类型，它是一个**有序的**集合，可以随时添加和删除其中的元素。

```python
listname = []  # 创建列表
listname = list()  # 创建列表
del listname  # 删除列表

# 添加元素3种方法
listname.append(obj)  # 在列表末尾添加新的对象
# obj 可以是任意类型的对象，包括单个元素、列表、元组、字典(看做一个元素)等
listname.extend(seq)  # 在列表末尾一次性追加另一个序列中的多个值
# seq 可以是单个元素、列表、元组、字典等，但不能是单个数字
listname.insert(index, obj)  # 将对象插入列表
# index -- 对象 obj 需要插入的索引位置，obj -- 要插入列表中的对象，类型和append一样

# 删除元素4种方法
del listname[index]  # del关键字，删除列表中指定位置的元素，也可以是切片
listname.pop(index)  # pop()方法，删除列表中指定位置的元素，不指定则删除最后一个元素
listname.remove(obj)  # remove()方法，删除列表中某个值的第一个匹配项
listname.clear()  # clear()方法，清空列表

# 修改元素2种方法
listname[index] = new_obj  # 直接修改列表中指定位置的元素
listname[1: 4] = [1, 2, 3]
"""
Python 支持通过切片语法给一组元素赋值。
在进行这种操作时，如果不指定步长（step 参数），
Python 就不要求新赋值的元素个数与原来的元素个数相同；
这意味，该操作既可以为列表添加元素，也可以为列表删除元素。
"""

# 查询元素2种方法
listname.index(obj，start, end)  # index()方法，返回列表中第一个匹配项的索引
listname.count(obj)  # count()方法，返回列表中某个值的出现次数
```

### range()函数

range()函数用来生成一个整数序列，语法格式如下：`range(start, end, step)`  
返回值是一个 range 对象，它是一个可迭代对象，可以通过 list() 函数将其转换成列表。

### 元组(tuple)()

元组（tuple）是 Python 中另一个重要的序列结构，和列表类似，元组也是由一系列按特定顺序排序的元素组成。  
元组和列表的区别在于，元组里的**元素是不可变的**，一旦创建，就不能修改。  
需要注意的一点是，当创建的元组中只有一个字符串类型的元素时，该元素后面必须要加一个逗号,，否则 Python
解释器会将它视为字符串。  
元组是不可变序列，元组中的元素不能被修改，所以我们只能创建一个新的元组去替代旧的元组。

### 字典(dict){}

字典（dict）是 Python 中最常用的数据类型，它是一个**无序的**键值对（key-value）集合。  
字典类型是 Python
中唯一的映射类型。“映射”是数学中的术语，简单理解，它指的是元素之间相互对应的关系，即通过一个元素，可以唯一找到另一个元素。  
Python 更推荐使用 dict 类型提供的 get() 方法来获取指定键对应的值。当指定的键不存在时，get() 方法不会抛出异常。
`dictname.get(key, default=None)`  
可使用`dir(dict)`查看字典的所有方法。  
keys()方法用来获取字典中所有的键，返回一个可迭代对象。  
values()方法用来获取字典中所有的值，返回一个可迭代对象。  
items()方法用来获取字典中所有的键值对，返回一个可迭代对象，其中每个元素都是一个元组。  
copy()方法用来对字典进行浅复制，返回一个新的字典。

### 集合(set){}

集合（set）是 Python 中提供的另一种内置的数据类型，它是一个**无序的**可迭代对象，它的**每个元素都是唯一且不可变的**。  
集合是一个无序的序列，所以不能通过索引来获取元素。  
集合是可变类型，但集合中的元素必须是不可变类型。

## 流程控制

### assert 断言

assert 语句可以看做是功能缩小版的 if 语句，它用于判断某个表达式的值，如果值为真，则程序可以继续往下执行；反之，Python 解释器会报
AssertionError 错误，抛出异常。  
assert 语句通常用于检查用户的输入是否符合规定，还经常用作程序初期测试和调试过程中的辅助工具。

```python
assert 条件表达式[, 参数]
# 条件表达式：可以是任意表达式，但结果必须为 True 或 False
# 参数：用来解释断言失败的原因
```

### 条件语句

Python
中的条件表达式可以用来简化代码，它的语法格式如下：`条件表达式为真时返回的结果 if 条件表达式 else 条件表达式为假时返回的结果`

### 循环语句

无论是 while 循环还是 for 循环，其后都可以紧跟着一个 else 代码块，它的作用是当循环条件为 False 跳出循环时，程序会最先执行
else 代码块中的代码。

### Python 推导式

Python 推导式是 Python 的一种独有特性，它可以从一个数据序列构建另一个新的数据序列。

### zip()函数

zip() 函数用于将多个可迭代对象中对应位置的元素打包成一个个元组，然后返回由这些元组组成的可迭代对象。  
zip() 函数只能打包**长度相同**的可迭代对象，当传入的可迭代对象长度不一致时，会以最短的可迭代对象长度为准进行截取。

## 函数

### 定义函数

定义函数需要用 def 关键字实现，语法格式如下：

```python
def 函数名(参数列表):
    函数体
    return 返回值
```

如果想定义一个没有任何功能的空函数，可以使用 pass 语句作为占位符。  
为了提高代码的可读性，可以在函数定义的下方添加文档字符串，用来对函数进行说明。  
函数的说明文档本质上就是一个字符串，可以通过函数的`__doc__`属性来获取，也可以使用 help() 函数来查看。

### None

None 是 Python 中表示**空对象**的常量，它不等同于 False、空字符串、空列表、0，也不等同于由这些元素组成的空对象。相当于 C 语言中的 NULL。

## 类和对象

## 模块和包

模块是 Python 程序架构的一个核心概念。模块可以理解为 Python 程序的一个功能部件，它本质上就是一个 Python 文件，后缀名是
.py，包含了 Python 对象定义和 Python 语句。  
导入模块的三种方式：

1. import 模块名
2. from 模块名 import 对象名
3. from 模块名 import \*
4. import 模块名 as 模块别名
5. from 模块名 import 对象名 as 对象别名

模块的下载安装：

1. 使用 pip 命令下载安装：`pip install 模块名`
2. 使用 conda 命令下载安装
3. 使用 IDE 自带的包管理工具下载安装

## 异常处理机制

Python 中的异常处理机制可以帮助我们处理程序在运行时可能出现的各种错误，让程序可以继续运行下去。  
Python 中的异常处理机制主要包含以下几个关键字：

1. try：用来检测可能出现错误的代码，放在 try 代码块中执行
2. except：用来处理 try 中发生的异常，except 是捕获异常并处理的代码块



因为线性回归是一种用来预测连续变量的方法，而不是用来对文本进行分类的方法。文本分类是一种监督学习的任务，需要用到能够处理离散标签的方法，如朴素贝叶斯、决策树、KNN 等。

聚类算法是一种无监督学习的方法，它不需要事先给数据打标签，而是根据数据的相似性或差异性将它们分成不同的类别。无监督学习的目的是发现数据中隐藏的结构或模式，而不是预测特定的结果。
