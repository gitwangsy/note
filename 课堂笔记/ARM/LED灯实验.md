# LED 灯实验

## 分析芯片手册的 GPIO 章节

### GPIO 简介

GPIO(General Purpose Input/Output) 即通用输入输出，是 ARM 处理器的一种外设，用于处理器与外部设备的数据交互。

### GPIO 寄存器

GPIO 寄存器分为两类：

1. 控制寄存器：用于配置 GPIO 的功能，包括模式、输出类型、输出速度、上下拉等。
2. 数据寄存器：用于读取或设置 GPIO 的数据，包括输入数据、输出数据。

### GPIOx_MODER 寄存器

GPIO 模式寄存器，用于配置 GPIO 的功能，32 位，每两位对应一个 GPIO 引脚，**共 16 个 GPIO 引脚**，每个引脚有 4 种功能：

1. 输入模式，00
2. 输出模式，01
3. 复用功能，10
4. 模拟功能，11

### GPIOx_OTYPER 寄存器

GPIO 输出类型寄存器，用于配置 GPIO 的输出类型，16 位，每位对应一个 GPIO 引脚，共 16 个 GPIO 引脚，每个引脚有 2 种输出类型：

1. 推挽输出，0
2. 开漏输出，1
3. 复用功能，10
4. 模拟功能，11

### GPIOx_OSPEEDR 寄存器

GPIO 输出速度寄存器，用于配置 GPIO 的输出速度，32 位，每两位对应一个 GPIO 引脚，共 16 个 GPIO 引脚，每个引脚有 4 种输出速度：

1. 低速输出，00
2. 中速输出，01
3. 高速输出，10

### GPIOx_PUPDR 寄存器

GPIO 上下拉寄存器，用于配置 GPIO 的上下拉，32 位，每两位对应一个 GPIO 引脚，共 16 个 GPIO 引脚，每个引脚有 4 种上下拉：

1. 无上下拉，00
2. 上拉，01
3. 下拉，10

### GPIOx_IDR 寄存器

GPIO 输入数据寄存器，用于读取 GPIO 的输入数据，16 位，每位对应一个 GPIO 引脚，共 16 个 GPIO 引脚。

### GPIOx_ODR 寄存器

GPIO 输出数据寄存器，用于设置 GPIO 的输出数据，16 位，每位对应一个 GPIO 引脚，共 16 个 GPIO 引脚，每个引脚有 2 种输出数据：

1. 低电平，0
2. 高电平，1

### GPIOE 寄存器

GPIOE 表示 GPIOE 外设，GPIOE 外设有 16 个 GPIO 引脚，每个引脚对应一个寄存器，共 16 个寄存器，每个寄存器占 32 位，每个寄存器的地址如下：

| 寄存器地址 | 引脚 | 寄存器地址 | 引脚 |
| ---------- | ---- | ---------- | ---- |
| 0x50006000 | PE0  | 0x50006040 | PE8  |
| 0x50006004 | PE1  | 0x50006044 | PE9  |
| 0x50006008 | PE2  | 0x50006048 | PE10 |
| 0x5000600C | PE3  | 0x5000604C | PE11 |
| 0x50006010 | PE4  | 0x50006050 | PE12 |
| 0x50006014 | PE5  | 0x50006054 | PE13 |
| 0x50006018 | PE6  | 0x50006058 | PE14 |
| 0x5000601C | PE7  | 0x5000605C | PE15 |

## 分析芯片手册的 RCC 章节

### RCC

RCC(Reset and Clock Control) 即复位和时钟控制，是 ARM 处理器的一种外设，用于控制处理器的复位和时钟。

### RCC_AHB4ENSETR 寄存器

RCC AHB4 外设时钟使能寄存器，用于控制 AHB4 总线上的外设时钟，32 位，每位对应一个外设时钟，共 32 个外设时钟，每个外设时钟有 2 种状态：

1. 未使能，0
2. 使能，1

## LED-灯实验

### 实验环境

- 开发板：STM32mp157c-dk2

### 代码

```asm
.text
.global _start
_start:
 /*LED1灯的初始化 ---> PE10
 PE10引脚：设置为通用的输出，推挽输出，
 低速模式，禁止上拉和下拉电阻 */

 /* 0. 使能GPIOE 外设的时钟源
  RCC_MP_AHB4ENSETR[4] = 0b1   寄存器地址 = 0x50000A28 */
 ldr r0, =0x50000A28  @ 准备地址
 ldr r1, [r0]   @ 将地址中的数据读到R1中
 orr r1, r1, #(0x1 << 4) @ 修改第4位的值为1
 str r1, [r0]   @ 将修改后的数据写回到地址中

 /* 1. 设置 PE10 引脚为输出模式
  GPIOE_MODER[21:20] = 0b01  寄存器地址 = 0x50006000 */
 ldr r0, =0x50006000
 ldr r1, [r0]
 and r1, r1, #(~(0x3 << 20))
 orr r1, r1, #(0x1 << 20)
 str r1, [r0]

 /* 2. 设置 PE10 引脚为推挽输出
  GPIOE_OTYPER[10] = 0b0     寄存器地址 = 0x50006004 */
 ldr r0, =0x50006004
 ldr r1, [r0]
 and r1, r1, #(~(0x1 << 10))
 str r1, [r0]

 /* 3. 设置 PE10 引脚为低速模式
  GPIOE_OSPEEDR[21:20] = 0b00   寄存器地址 = 0x50006008 */
 ldr r0, =0x50006008
 ldr r1, [r0]
 and r1, r1, #(~(0x3 << 20))
 str r1, [r0]

 /* 4. 设置 PE10 引脚禁止上拉和下拉电阻
  GPIOE_PUPDR[21:20] = 0b00     寄存器地址 = 0x5000600C */
 ldr r0, =0x5000600C
 ldr r1, [r0]
 and r1, r1, #(~(0x3 << 20))
 str r1, [r0]

 /* 裸机开发中，必须有一个死循环，防止程序跑飞 */
 loop:
  /* 5. 设置PE10引脚输出高电平
   GPIOE_ODR[10] = 0b1   寄存器地址 = 0x50006014 */
  ldr r0, =0x50006014
  ldr r1, [r0]
  orr r1, r1, #(0x1 << 10)
  str r1, [r0]

  bl delay_1s  @ 调用延时函数
  /* 6. 设置PE10引脚输出低电平
   GPIOE_ODR[10] = 0b0   寄存器地址 = 0x50006014 */
  ldr r0, =0x50006014
  ldr r1, [r0]
  and r1, r1, #(~(0x1 << 10))
  str r1, [r0]

  bl delay_1s
  b loop

@ 大概 1s的延时函数
delay_1s:
 mov r3, #0x10000000
 mm:
 cmp r3, #0
 subne r3, r3, #1
 bne mm
 mov pc, lr

.end
```

```c
#include "stm32mp157c-dk2.h"

int main(void)
{
 // 使能 GPIOE 时钟
 RCC->AHB1ENR |= (1 << 21);

 // 配置 GPIOE 引脚 2 为输出模式
 GPIOE->MODER &= ~(3 << 2 * 2);
 GPIOE->MODER |= (1 << 2 * 2);

 // 配置 GPIOE 引脚 2 为推挽输出
 GPIOE->OTYPER &= ~(1 << 2);

 // 配置 GPIOE 引脚 2 为高速输出
 GPIOE->OSPEEDR &= ~(3 << 2 * 2);
 GPIOE->OSPEEDR |= (2 << 2 * 2);

 // 配置 GPIOE 引脚 2 为无上下拉
 GPIOE->PUPDR &= ~(3 << 2 * 2);

 while (1)
 {
  // 设置 GPIOE 引脚 2 为高电平
  GPIOE->ODR |= (1 << 2);

  // 延时
  for (int i = 0; i < 1000000; i++)
   ;

  // 设置 GPIOE 引脚 2 为低电平
  GPIOE->ODR &= ~(1 << 2);

  // 延时
  for (int i = 0; i < 1000000; i++)
   ;
 }
}
```
