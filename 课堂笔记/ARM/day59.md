# 软件环境

## keil5

keil 是一款集成开发环境，可以用来编写、编译、调试、下载程序，还可以用来仿真程序，查看程序运行过程中的寄存器值、内存值等。

主要用于单片机的开发，支持多种单片机，包括 51、STM32、LPC 等。

## 文件

### .s 汇编文件

```assembly
@ 第一个汇编程序
@ 1. 定义程序入口
.text @ 代码段
.global _start @ 定义程序入口
_start: @ 程序入口
mov r0, #0x55 @ 将 0x55 赋值给 r0

stop: @ 停止
b stop @ 无条件跳转到 stop 标号处
.end @ 结束
```

### .lds 链接脚本文件

链接脚本文件是用来描述程序的内存布局的，包括程序的起始地址、程序的结束地址、程序的入口地址、程序的栈顶地址等。

## 汇编语言

### 汇编语言的基本语法

汇编语言的基本语法包括指令、标号、注释等。

#### 指令

指令是汇编语言的基本语句，汇编语言的指令包括伪指令和机器指令。

##### 机器指令

机器指令是汇编语言的一种指令，它是由 **CPU 直接执行**的指令，用来**完成特定的功能**。

如 `mov`、`b` 等。

##### 伪指令

伪指令是汇编语言的一种指令，它不是机器指令，而是由**汇编器执行**的指令，用来**控制汇编器的工作**。

伪指令的特点是以 `.` 开头，如 `.text`、`.global`、`.end` 等。

#### 标号

它是一个标识符，用来**标识一个地址**。

标号的特点是以 `:` 结尾，如 `_start:`、`stop:` 等。

#### 注释

用来说明程序的作用、功能等。

注释的特点是以 `@` 开头，如 `@ 第一个汇编程序`、`@ 定义程序入口` 等。

### 汇编指令分类

1. 数据操作指令
   数据操作指令用来对数据进行操作，包括数据传送指令、算术运算指令、逻辑运算指令、移位指令等。
2. 跳转指令
3. 程序状态寄存器操作指令
4. Load/Store 内存操作指令
   包括单寄存器操作指令、多寄存器操作指令、栈操作指令等。
5. 软中断指令

### 汇编指令语法

#### 数据传送指令

数据传送指令用来将数据从一个位置传送到另一个位置，包括单寄存器传送指令、双寄存器传送指令、立即数传送指令等。

| 指令 | 说明                         |
| ---- | ---------------------------- |
| mov  | 单寄存器传送指令             |
| mvn  | 单寄存器传送指令，传送前取反 |
| moveq| 单寄存器传送指令，传送前判断相等 |
| movne| 单寄存器传送指令，传送前判断不等 |

```assembly
mov r0, #0x55 @ 将 0x55 赋值给 r0
mov r1, r0 @ 将 r0 的值赋值给 r1
mvn r2, r1 @ 将 r1 的值取反后赋值给 r2
```

**立即数**：直接给出的数值，如 `#0x55`、`#0b10101010`、`#0o52`、`#85` 等。

**伪指令** `LDR` 用来将数据从内存中传送到寄存器中。

```assembly
ldr r0, =0x55 @ 将 0x55 从内存中传送到 r0 中
```

#### 移位指令

移位指令用来对数据进行移位操作，包括逻辑左移指令、逻辑右移指令、算术右移指令、循环右移指令等。

| 指令 | 说明         |
| ---- | ------------ |
| lsl  | 逻辑左移指令 |
| lsr  | 逻辑右移指令 |
| asr  | 算术右移指令 |
| ror  | 循环右移指令 |

三者的区别是：

- 逻辑右移指令：右移后左边补 0
- 算数右移指令：右移后左边补符号位
- 循环右移指令：右移后左边补右移的最后一位

```assembly
mov r0, #0x55 @ 将 0x55 赋值给 r0
lsl r1, r0, #1 @ 将 r0 的值逻辑左移 1 位后赋值给 r1
asr r2, r1, #1 @ 将 r1 的值算术右移 1 位后赋值给 r2
ror r3, r2, #1 @ 将 r2 的值循环右移 1 位后赋值给 r3

mov r4, r0, lsl #1 @ 将 r0 的值逻辑左移 1 位后赋值给 r4
mov r5, #0x55, lsl #1 @ 将 0x55 的值逻辑左移 1 位后赋值给 r5
```

#### 逻辑运算指令

逻辑运算指令用来对数据进行逻辑运算，包括与运算指令、或运算指令、异或运算指令、取反运算指令等。

| 指令 | 说明         |
| ---- | ------------ |
| and  | 与运算指令   |
| orr  | 或运算指令   |
| eor  | 异或运算指令 |
| bic  | 取反运算指令 |

口诀：

> 与 0 置 0，与 1 不变；
> 或 1 置 1，或 0 不变；
> 异或 1 取反，异或 0 不变；

```assembly
mov r0, #0x55 @ 将 0x55 赋值给 r0
mov r1, #0xaa @ 将 0xaa 赋值给 r1
and r2, r0, r1 @ 将 r0 和 r1 的值进行与运算后赋值给 r2
orr r3, r0, r1 @ 将 r0 和 r1 的值进行或运算后赋值给 r3
eor r4, r0, r1 @ 将 r0 和 r1 的值进行异或运算后赋值给 r4
bic r5, r0, r1 @ 将 r0 和 r1 的值进行取反运算后赋值给 r5

mov r5, r0, and r1 @ 将 r0 和 r1 的值进行与运算后赋值给 r5
mov r6, #0x55, and #0xaa @ 将 0x55 和 0xaa 的值进行与运算后赋值给 r6
```

#### 算术运算指令

算术运算指令用来对数据进行算术运算，包括加法指令、减法指令、乘法指令、除法指令、取模指令等。

| 指令 | 说明     |
| ---- | -------- |
| add  | 加法指令 |
| adc  | 进位指令 |
| sub  | 减法指令 |
| sbc  | 借位指令 |
| mul  | 乘法指令 |
| div  | 除法指令 |

```assembly
mov r0, #0x55 @ 将 0x55 赋值给 r0
mov r1, #0xaa @ 将 0xaa 赋值给 r1
add r2, r0, r1 @ 将 r0 和 r1 的值进行加法运算后赋值给 r2
adc r3, r0, r1 @ 将 r0 和 r1 的值进行进位运算后赋值给 r3
...
@ 准备两个64位的数
mov r0, #0xFFFFFFFE  @ 第1个64位数的低32位
mov r1, #0x3   @ 第1个64位数的高32位
mov r2, #0x4   @ 第2个64位数的低32位
mov r3, #0x5   @ 第2个64位数的高32位

@ 先完成低32位的加法运算
@ s： 指令的执行结果影响CPSR的NZCV位
adds r4, r0, r2     @ r4 = r0 + r2 = 0x2
@ 在完成高32位的加法运算
adc r5, r1, r3     @ r5 = r1 + r3 + C位 = 0x9

@ 案例2：实现两个64位数相减
@ r0和R1存放第1个64位的数
@ r2和r3存放第2个64位的数
@ r4和r5存放运算的结果

@ 准备两个64位的数
mov r0, #0x3  @ 第1个64位数的高32位
mov r2, #0x4  @ 第2个64位数的低32位
mov r3, #0x5  @ 第2个64位数的高32位

@ 先完成低32位的减法运算
subs r4, r0, r2     @ r4 = r0 - r2 = 0xFFFFFFFF
@ 在完成高32位的减法运算
sbc  r5, r1, r3     @ r5 = r1 - r3 - !C = 0x3
```

#### 比较指令

比较指令用来对数据进行比较，包括比较指令、比较立即数指令、比较高低位指令等。

| 指令 | 说明           |
| ---- | -------------- |
| cmp  | 比较指令       |
| cmn  | 比较立即数指令 |
| tst  | 比较高低位指令 |

```assembly
mov r0, #0x55 @ 将 0x55 赋值给 r0
mov r1, #0xaa @ 将 0xaa 赋值给 r1
cmp r0, r1 @ 将 r0 和 r1 的值进行比较后赋值给 CPSR
cmn r0, r1 @ 将 r0 和 r1 的值进行比较后赋值给 CPSR
tst r0, r1 @ 将 r0 和 r1 的值进行比较后赋值给 CPSR
```

#### 跳转指令

跳转指令用来实现程序的跳转，包括无条件跳转指令、条件跳转指令、子程序跳转指令等。

| 指令 | 说明           |
| ---- | -------------- |
| b    | 无条件跳转指令 |
| bl   | 子程序跳转指令 |
| bx   | 跳转指令       |

```assembly
mov r0, #0x55 @ 将 0x55 赋值给 r0
mov r1, #0xaa @ 将 0xaa 赋值给 r1
cmp r0, r1 @ 将 r0 和 r1 的值进行比较后赋值给 CPSR
bne label1 @ 如果 CPSR 的 Z 位为 0，则跳转到 label1 标签处
beq label2 @ 如果 CPSR 的 Z 位为 1，则跳转到 label2 标签处
```

#### 程序状态寄存器操作指令

程序状态寄存器操作指令用来对程序状态寄存器进行操作，包括读取程序状态寄存器的值、修改程序状态寄存器的值等。

| 指令 | 说明           |
| ---- | -------------- |
| mrs  | 读取 CPSR 的值 |
| msr  | 修改 CPSR 的值 |

```assembly
mrs r0, cpsr @ 将 CPSR 的值赋值给 r0
msr cpsr, r0 @ 将 r0 的值赋值给 CPSR
```

#### Load/Store 指令

Load/Store 指令用来实现数据的读取和存储，包括读取字节指令、读取半字指令、读取字指令、读取双字指令、存储字节指令、存储半字指令、存储字指令、存储双字指令等。

r 4 字节，rh 2 字节，rb 1 字节

ld : load st:store r : register h : half b:byte

##### 单寄存器操作指令

| 指令 | 说明         |
| ---- | ------------ |
| ldr  | 读取字指令   |
| ldrh | 读取半字指令 |
| ldrb | 读取字节指令 |
| str  | 存储字指令   |
| strh | 存储半字指令 |
| strb | 存储字节指令 |

```assembly
ldr r0, =0x55 @ 将 0x55 赋值给 r0
ldr r1, =0xaa @ 将 0xaa 赋值给 r1

ldr r0, [r1] @ 将 r1 的值作为地址，读取该地址的值赋值给 r0
ldr r0, [r1, #4] @ 将 r1 + 4 的值作为地址，读取该地址的值赋值给 r0
ldr r0, [r1, #4]! @ 将 r1 + 4 的值作为地址，读取该地址的值赋值给 r0，然后 r1 = r1 + 4
ldr r0, [r1], #4 @ 将 r1 的值作为地址，读取该地址的值赋值给 r0，然后 r1 = r1 + 4

str r0, [r1] @ 将 r1 的值作为地址，将 r0 的值存储到该地址
str r0, [r1, #4] @ 将 r1 + 4 的值作为地址，将 r0 的值存储到该地址
```

##### 多寄存器操作指令

| 指令 | 说明       |
| ---- | ---------- |
| ldm  | 读取字指令 |
| stm  | 存储字指令 |

```assembly
ldm r0, {r1, r2, r3} @ 将 r0 的值作为地址，读取该地址的值赋值给 r1、r2、r3
ldm r0, {r1-r3} @ 将 r0 的值作为地址，读取该地址的值赋值给 r1、r2、r3

stm r0, {r1, r2, r3} @ 将 r0 的值作为地址，将 r1、r2、r3 的值存储到该地址
stm r0, {r1-r3} @ 将 r0 的值作为地址，将 r1、r2、r3 的值存储到该地址
```

##### 栈空间操作指令

栈的种类：

1. 增栈：压栈之后，栈指针向高地址方向移动。
2. 减栈：压栈之后，栈指针向低地址方向移动。
3. 满栈：当前栈指针指针的栈空间中有有效的数据，如果需要压栈，需要先移动栈指针，让栈指针指向一个空的位置，然后再压入数据，
   此时栈指针指向的空间依然是有有效数据的。
4. 空栈：当前栈指针指向的空间没有有效的数据，可以先压入数据，压入数据之后需要移动栈指针，让栈指针再次指向一个空的位置。

满增栈：Full Ascending
满减栈：Full Descending
空增栈：Empty Ascending
空减栈：Empty Descending

栈的操作指令：

满增栈：stmfa / ldmfa
**满减栈**：stmfd / ldmfd
空增栈：stmea / ldmea
空减栈：stmed / ldmed

ARM 处理器默认采用的是满减栈的操作指令。

```assembly
stmfd sp!, {r0-r3} @ 将 r0、r1、r2、r3 的值存储到 sp 的地址，然后 sp = sp - 16
ldmfd sp!, {r0-r3} @ 将 sp 的值作为地址，读取该地址的值赋值给 r0、r1、r2、r3，然后 sp = sp + 16
```

#### 软件中断指令

软件中断指令用来实现软件中断，包括软件中断指令和软件中断返回指令。

| 指令 | 说明         |
| ---- | ------------ |
| swi  | 软件中断指令 |

```assembly
swi 0x123456 @ 软件中断，中断号为 0x123456
```
