# 内存

1. 程序在计算机中如何运行？

   程序在计算机中运行时，首先需要将程序从硬盘中加载到内存中，然后 CPU 从内存中读取指令并执行，最后将结果写回内存。**CPU 通过地址总线（Address Bus）来读取内存中的指令和数据，通过数据总线（Data Bus）来写入数据。**

   对于 CPU 来说，内存仅仅是一个存放指令和数据的地方，并不能在内存中完成计算功能。

   寄存器（Register）是 CPU 内部非常小、非常快速的存储部件，它的容量很有限，对于 32 位的 CPU，每个寄存器一般能存储 32 位（4 个字节）的数据，**对于 64 位的 CPU，每个寄存器一般能存储 64 位（8 个字节）的数据**。为了完成各种复杂的功能，现代 CPU 都内置了几十个甚至上百个的寄存器，嵌入式系统功能单一，寄存器数量较少。我们经常听说多少位的 CPU，指的就是寄存器的的位数，**也是 CPU 能够支持的数据总线的最大根数**。
   ![img](F:\BaiduSyncdisk\TyporaNote\pictureNote\10410L420-0.jpg)

   寄存器在程序的执行过程中至关重要，不可或缺，它们可以用来完成数学运算、控制循环次数、控制程序的执行流程、标记 CPU 运行状态等。

   在 CPU 内部设置一个缓存，可以将使用频繁的数据暂时读取到缓存，需要同一地址上的数据时，就不用大老远地再去访问内存，直接从缓存中读取即可。(缓存命中率)

   CPU 指令：汇编指令(add,sub,cmp,mov)经过简单的转换成为 CPU 指令

2. 虚拟内存（Virtual Memory）？

   虚拟地址的整个想法是这样的：把程序给出的地址看做是一种虚拟地址（Virtual Address），然后通过某些映射的方法，将这个虚拟地址转换成实际的物理地址。这样，只要我们能够妥善地控制这个虚拟地址到物理地址的映射过程，就可以保证程序每次运行时都可以使用相同的地址。
   **使用虚拟地址能够，1 使不同程序的地址空间相互隔离,2 提高内存使用效率。**
   操作系统（Operating System，简称 OS）为我们解决了这个问题：当程序运行需要的空间大于内存容量时，会将内存中暂时不用的数据再写回硬盘；需要这些数据时再从硬盘中读取，并将另外一部分不用的数据写入硬盘。这样，**硬盘中就会有一部分空间用来存放内存中暂时不用的数据。这一部分空间也叫做虚拟内存（Virtual Memory）。**![CPU、内存、硬盘和主板的关系](F:\BaiduSyncdisk\TyporaNote\pictureNote\1I05B017-0.png)

   中间层思想：在计算机中，为了让操作更加直观、易于理解、增强用户体验，开发者经常会使用一件法宝——增加中间层，即使用一种间接的方式来屏蔽复杂的底层细节，只给用户提供简单的接口。虚拟地址是使用中间层的一个典型例子。
   虚拟地址和虚拟内存的区别如下：

   - 虚拟地址是程序访问存储器所使用的逻辑地址，它不是真实的物理内存地址，而是通过 CPU 的转换才能对应到物理地址。虚拟地址空间是虚拟地址的集合，它有一个固定的范围，例如 32 位系统的虚拟地址空间为 4G。
   - 虚拟内存是一种内存管理技术，它将程序使用到的虚拟地址映射到计算机内存中的物理地址，同时利用分页技术将实际的物理内存分配给虚拟内存。虚拟内存使得应用程序可以使用比物理内存大小更多的内存空间，提高了内存隔离带来的安全性和效率。
   - 简而言之，虚拟地址是程序看到的内存地址，虚拟内存是操作系统管理的内存空间。

3. CPU
   **数据总线**和**主频**都是 CPU 的重要指标：数据总线决定了 CPU 单次的数据处理能力，主频决定了 CPU 单位时间内的数据处理次数，它们的乘积就是 CPU 单位时间内的数据处理量。
   主频因为硅晶体的物体特性很难再提升，只能向**多核**方向发展。
   **数据总线和地址总线不是一回事**，数据总线用于在 CPU 和内存之间传输数据，地址总线用于在内存上定位数据，它们之间没有必然的联系，宽度并不一定相等。实际情况是，地址总线的宽度往往随着数据总线的宽度而增长，以访问更大的内存。
   实际支持的物理内存：CPU 支持的物理内存只是理论上的数据，实际应用中还会受到操作系统的影响。

   > **在 32 位模式下**，一个指针或地址占用 4 个字节的内存，共有 32 位，理论上能够访问的虚拟内存空间大小为 2^32 = 0X100000000 Bytes，即 4GB，有效虚拟地址范围是 0 ~ 0XFFFFFFFF。 换句话说，**程序能够使用的最大内存为 4GB，跟物理内存没有关系。**我们的程序只管使用 4GB 的内存，不用关心硬件资源够不够。如果物理内存大于 4GB，例如目前很多 PC 机都配备了 8GB 的内存，那么程序也无能为力，它只能够使用其中的 4GB。
   > **在 64 位编译模式下**，所以 Windows 和 Linux 都对虚拟地址进行了限制，仅使用虚拟地址的低 48 位（6 个字节），总的虚拟地址空间大小为 2^48 = **256TB**。
   > 目前计算机可以说已经进入了 64 位的时代，之所以还要提供 32 位编译模式，是为了兼容一些老的硬件平台和操作系统，或者某些场合下 32 位的环境已经足够，使用 64 位环境会增大成本，例如嵌入式系统、单片机、工控等。
   > **这里所说的 32 位环境是指：32 位的 CPU + 32 位的操作系统 + 32 位的程序。**

   CPU 通过地址总线来访问内存，一次能处理几个字节的数据，就命令地址总线读取几个字节的数据。(4/8，少了浪费主频，多了没用)

   > **内存对齐：**以 32 位的 CPU 为例，实际寻址的步长为 4 个字节，也就是**只对编号为 4 的倍数的内存寻址**。将一个数据尽量放在一个步长之内，避免跨步长存储，这称为**内存对齐**。
   > 除了结构体，**变量有时候也会进行内存对齐**。
   > 内存对齐虽然和硬件有关，但是决定对齐方式的是编译器，如果你的硬件是 64 位的，却以 32 位的方式编译，那么还是会按照 4 个字节对齐。
   > 内存对齐不是 C 语言的特性，**属于计算机的运行原理**。

4. 内存分页机制

   > 完成虚拟地址的映射以整个程序为单位进行映射的话，不仅会将暂时用不到的数据从磁盘中读取到内存，也会将过多的数据一次性写入磁盘，这会严重降低程序的运行效率。
   > 现代计算机都**使用分页（Paging）的方式对虚拟地址空间和物理地址空间进行分割和映射，以减小换入换出的粒度，提高程序运行效率。**
   > 分页（Paging）的思想是指把地址空间人为地分成大小相等（并且固定）的若干份，这样的一份称为一页，就像一本书由很多页面组成，每个页面的大小相等。如此，就能够以页为单位对内存进行换入换出：
   >
   > - 当程序运行时，只需要将必要的数据从磁盘读取到内存，暂时用不到的数据先留在磁盘中，什么时候用到什么时候读取。
   > - 当物理内存不足时，只需要将原来程序的部分数据写入磁盘，腾出足够的空间即可，不用把整个程序都写入磁盘。

   目前几乎所有 PC 上的操作系统都是用 4KB 大小的页。假设我们使用的 PC 机是 32 位的，那么虚拟地址空间总共有 4GB，按照 4KB 每页分的话，总共有 2^32 / 2^12 = 2^20 = 1M = 1048576 个页；物理内存也是同样的分法。

5. Linux 下 C 语言程序的内存布局
