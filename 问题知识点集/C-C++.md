1. (数组与指针)scanf("%s",指针接收有错);？
     ​	因为这里指针是指针类型，只能接收地址；如果这里是char类型的数组就可以，因为在这里数组名除了代表首地址，还代表数组这个数据集合，是有存储空间的。这也是数组不能完全和指针等价的原因，数组名还可以表示自己是个“数组”。

2. (编码)utf-8编码兼容ascii，utf-16兼容吗?(不兼容，2个字节)

     ASCII 码中，一个英文字母（不分大小写）为一个字节，一个中文汉字为两个字节。
     UTF-8 编码中，一个英文字为一个字节，一个中文为三个字节。
     Unicode 编码中，一个英文为一个字节，一个中文为两个字节。
     符号：英文标点为一个字节，中文标点为两个字节。例如：英文句号 . 占1个字节的大小，中文句号 。占2个字节的大小。
     UTF-16 编码中，一个英文字母字符或一个汉字字符存储都需要 2 个字节（Unicode 扩展区的一些汉字存储需要 4 个字节）。
     UTF-32 编码中，世界上任何字符的存储都需要 4 个字节。

3. (数组与指针)数组名是常量，右值。

4. 存储对齐，注意最后算完一定是占用内存最大元素的整数倍。
     \#pragma pack () 和自身冲突时，选择两个中的min值。

5. ！pos只能对0判断，正数和负数都为真(!pos为假)。

6. 计算机对二进制数进行的运算，符号位共同参与运算的运算叫位运算。（6种）

   | 按位与 | 按位或 |  非  | 异或 | 按位左移 | 按位右移 |
   | :----: | :----: | :--: | :--: | :------: | :------: |
   |   &    |   \|   |  ~   |  ^   |    <<    |    >>    |


   左移高位丢弃地位补0（\*2），右移无符号高位补0(/2)，有符号不同编译器处理方法不同，有的补符号位（算术右移），有的补0（逻辑右移）。

   负数按补码形式参与按位与或运算。   
   * & : 1.清零`任何数 & 0`

   		2.指定位置零`取低四位(高四位置零) 1010 1110 & (1<<4-1) = 0000 1110`
   					`取高四位 1010 1110 >> 4 = 0000 1010`


   		3.判断奇偶`判断二进制末位 (a&1) <=> (a%2)`

   * | : 1.指定位置一`低四位置一 1010 1110 | 0000 1111 = 1010 1111`

   * ~ : 1.指定位置零`1010 1110 & ~(1<<2) = 1010 1010`

   		2.指定位置一`1010 1110 | (1<<0) = 1010 1111`

   * ^ : 1.指定位翻转`低四位翻转 1010 1110 ^ 0000 1111 = 1010 0001`

   		2.与零异或值不变`1010 1110 ^ 0 = 1010 1110`

7. define 定义数据类型 和 typedef 定义数据类型 的使用场景区别？
     一般来说，如果只是为了定义一个简单的别名，可以使用define；如果需要定义新的数据类型，则应该使用typedef。
8. main函数里如何选择return exit()?
     使用 `return 0` 和 `exit(0)` 都可以用于表示程序正常退出，并返回一个退出状态码 0。如果只是希望程序在执行完 `main` 函数后正常退出，那么使用 `return 0` 就足够了。但如果需要在退出前执行一些清理工作，比如释放动态分配的内存等，那么使用 `exit(0)` 可能更合适。
9. 与strncpy函数和strlcpy函数不同，snprintf函数不仅可以复制字符串，还可以进行格式化输出，能够满足更多的字符串处理需求。同时，通过限制输出的字符数，也可以避免缓冲区溢出的问题。
10. **逗号运算符**是指在C语言中，多个表达式可以用逗号分开，其中用逗号分开的表达式的值分别结算，但**整个表达式的值是最后一个表达式的值**。
11. char *s = "hello";和char s[] = "hello";的区别？
        char *s = "hello"; 声明了一个指向字符常量的指针，它指向字符串"hello"在内存中的位置。这意味着该字符串是不可修改的，任何尝试修改它的操作都会导致未定义的行为。
        char s[] = "hello"; 声明了一个字符数组，它包含字符串"hello"的副本。这个数组是可修改的，因为它在内存中有自己的存储空间。您可以通过修改数组中的元素来修改字符串。
12. 位域
         位域是指把一个字节中的二进制位划分为几个不同的区域，并对每个区域规定一个域名，每个域二进制位的长度可以不同。这样就可以把几个不同的数据项用一个字节的二进制位域来表示，从而节省存储空间。位域的声明形式如下：
            struct {
            	unsigned int a:1;
            	unsigned int b:3;
            	unsigned int c:4;
            } bit, *pbit;
        位域的具体存储规则如下：
          1. 当相邻成员的类型相同时，如果它们的位宽之和小于类型的 sizeof 大小，那么后面的成员紧邻前一个成员存储，直到不能容纳为止；如果它们的位宽之和大于类型的 sizeof 大小，那么后面的成员将从新的存储单元开始，其偏移量为类型大小的整数倍。
          2. 当相邻成员的类型不同时，不同的编译器有不同的实现方案，GCC 会压缩存储，而 VC/VS 不会。
          3. 如果成员之间穿插着非位域成员，那么不会进行压缩。
        通过上面的分析，我们发现位域成员往往不占用完整的字节，有时候也不处于字节的开头位置，因此使用&获取位域成员的地址是没有意义的，C语言也禁止这样做。地址是字节（Byte）的编号，而不是位（Bit）的编号。
        无名位域一般用来作填充或者调整成员位置。因为没有名称，无名位域不能使用。